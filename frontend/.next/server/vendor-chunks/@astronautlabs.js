/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@astronautlabs";
exports.ids = ["vendor-chunks/@astronautlabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/assert.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/assert.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert)\n/* harmony export */ });\nvar assert = /** @class */ (function () {\r\n    function assert() {\r\n    }\r\n    assert.ok = function (predicate, message) {\r\n        if (!predicate)\r\n            throw new Error(message);\r\n    };\r\n    assert.equal = function (value, expected, message) {\r\n        if (value !== expected)\r\n            throw new Error(message);\r\n    };\r\n    return assert;\r\n}());\r\n\r\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2lCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHdoaXN0bGV4L2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bhc3Ryb25hdXRsYWJzL2pzb25wYXRoL2Rpc3QuZXNtL2Fzc2VydC5qcz83NjEwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NlcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBhc3NlcnQoKSB7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQub2sgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiAodmFsdWUsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBleHBlY3RlZClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBhc3NlcnQ7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IGFzc2VydCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/esprima.js":
/*!******************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/esprima.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Syntax: () => (/* binding */ Syntax),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   tokenize: () => (/* binding */ tokenize),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/*\r\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\r\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\r\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\r\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\r\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\r\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\r\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\r\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\r\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\r\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\r\n\r\n  Redistribution and use in source and binary forms, with or without\r\n  modification, are permitted provided that the following conditions are met:\r\n\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n    * Redistributions in binary form must reproduce the above copyright\r\n      notice, this list of conditions and the following disclaimer in the\r\n      documentation and/or other materials provided with the distribution.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n/*jslint bitwise:true plusplus:true */\r\n/*global esprima:true, define:true, exports:true, window: true,\r\nthrowErrorTolerant: true,\r\nthrowError: true, generateStatement: true, peek: true,\r\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\r\nparseFunctionDeclaration: true, parseFunctionExpression: true,\r\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\r\nparseLeftHandSideExpression: true,\r\nparseUnaryExpression: true,\r\nparseStatement: true, parseSourceElement: true */\r\nvar Token, TokenName, FnExprTokens, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;\r\nToken = {\r\n    BooleanLiteral: 1,\r\n    EOF: 2,\r\n    Identifier: 3,\r\n    Keyword: 4,\r\n    NullLiteral: 5,\r\n    NumericLiteral: 6,\r\n    Punctuator: 7,\r\n    StringLiteral: 8,\r\n    RegularExpression: 9\r\n};\r\nTokenName = {};\r\nTokenName[Token.BooleanLiteral] = 'Boolean';\r\nTokenName[Token.EOF] = '<end>';\r\nTokenName[Token.Identifier] = 'Identifier';\r\nTokenName[Token.Keyword] = 'Keyword';\r\nTokenName[Token.NullLiteral] = 'Null';\r\nTokenName[Token.NumericLiteral] = 'Numeric';\r\nTokenName[Token.Punctuator] = 'Punctuator';\r\nTokenName[Token.StringLiteral] = 'String';\r\nTokenName[Token.RegularExpression] = 'RegularExpression';\r\n// A function following one of those tokens is an expression.\r\nFnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\r\n    'return', 'case', 'delete', 'throw', 'void',\r\n    // assignment operators\r\n    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\r\n    '&=', '|=', '^=', ',',\r\n    // binary/unary operators\r\n    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\r\n    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\r\n    '<=', '<', '>', '!=', '!=='];\r\nvar Syntax = {\r\n    AssignmentExpression: 'AssignmentExpression',\r\n    ArrayExpression: 'ArrayExpression',\r\n    BlockStatement: 'BlockStatement',\r\n    BinaryExpression: 'BinaryExpression',\r\n    BreakStatement: 'BreakStatement',\r\n    CallExpression: 'CallExpression',\r\n    CatchClause: 'CatchClause',\r\n    ConditionalExpression: 'ConditionalExpression',\r\n    ContinueStatement: 'ContinueStatement',\r\n    DoWhileStatement: 'DoWhileStatement',\r\n    DebuggerStatement: 'DebuggerStatement',\r\n    EmptyStatement: 'EmptyStatement',\r\n    ExpressionStatement: 'ExpressionStatement',\r\n    ForStatement: 'ForStatement',\r\n    ForInStatement: 'ForInStatement',\r\n    FunctionDeclaration: 'FunctionDeclaration',\r\n    FunctionExpression: 'FunctionExpression',\r\n    Identifier: 'Identifier',\r\n    IfStatement: 'IfStatement',\r\n    Literal: 'Literal',\r\n    LabeledStatement: 'LabeledStatement',\r\n    LogicalExpression: 'LogicalExpression',\r\n    MemberExpression: 'MemberExpression',\r\n    NewExpression: 'NewExpression',\r\n    ObjectExpression: 'ObjectExpression',\r\n    Program: 'Program',\r\n    Property: 'Property',\r\n    ReturnStatement: 'ReturnStatement',\r\n    SequenceExpression: 'SequenceExpression',\r\n    SwitchStatement: 'SwitchStatement',\r\n    SwitchCase: 'SwitchCase',\r\n    ThisExpression: 'ThisExpression',\r\n    ThrowStatement: 'ThrowStatement',\r\n    TryStatement: 'TryStatement',\r\n    UnaryExpression: 'UnaryExpression',\r\n    UpdateExpression: 'UpdateExpression',\r\n    VariableDeclaration: 'VariableDeclaration',\r\n    VariableDeclarator: 'VariableDeclarator',\r\n    WhileStatement: 'WhileStatement',\r\n    WithStatement: 'WithStatement'\r\n};\r\nPropertyKind = {\r\n    Data: 1,\r\n    Get: 2,\r\n    Set: 4\r\n};\r\n// Error messages should be identical to V8.\r\nMessages = {\r\n    UnexpectedToken: 'Unexpected token %0',\r\n    UnexpectedNumber: 'Unexpected number',\r\n    UnexpectedString: 'Unexpected string',\r\n    UnexpectedIdentifier: 'Unexpected identifier',\r\n    UnexpectedReserved: 'Unexpected reserved word',\r\n    UnexpectedEOS: 'Unexpected end of input',\r\n    NewlineAfterThrow: 'Illegal newline after throw',\r\n    InvalidRegExp: 'Invalid regular expression',\r\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\r\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\r\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\r\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\r\n    NoCatchOrFinally: 'Missing catch or finally after try',\r\n    UnknownLabel: 'Undefined label \\'%0\\'',\r\n    Redeclaration: '%0 \\'%1\\' has already been declared',\r\n    IllegalContinue: 'Illegal continue statement',\r\n    IllegalBreak: 'Illegal break statement',\r\n    IllegalReturn: 'Illegal return statement',\r\n    StrictModeWith: 'Strict mode code may not include a with statement',\r\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\r\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\r\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\r\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\r\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\r\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\r\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\r\n    StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\r\n    AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\r\n    AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\r\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\r\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\r\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\r\n    StrictReservedWord: 'Use of future reserved word in strict mode'\r\n};\r\n// See also tools/generate-unicode-regex.py.\r\nRegex = {\r\n    NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\r\n    NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\r\n};\r\n// Ensure the condition is true, otherwise throw an error.\r\n// This is only to have a better contract semantic, i.e. another safety net\r\n// to catch a logic error. The condition shall be fulfilled in normal case.\r\n// Do NOT use this to enforce a certain condition on any user input.\r\nfunction assert(condition, message) {\r\n    /* istanbul ignore if */\r\n    if (!condition) {\r\n        throw new Error('ASSERT: ' + message);\r\n    }\r\n}\r\nfunction isDecimalDigit(ch) {\r\n    return (ch >= 48 && ch <= 57); // 0..9\r\n}\r\nfunction isHexDigit(ch) {\r\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\r\n}\r\nfunction isOctalDigit(ch) {\r\n    return '01234567'.indexOf(ch) >= 0;\r\n}\r\n// 7.2 White Space\r\nfunction isWhiteSpace(ch) {\r\n    return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\r\n        (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\r\n}\r\n// 7.3 Line Terminators\r\nfunction isLineTerminator(ch) {\r\n    return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\r\n}\r\n// 7.6 Identifier Names and Identifiers\r\nfunction isIdentifierStart(ch) {\r\n    return (ch == 0x40) || // @ (for jsonpath)\r\n        (ch === 0x24) || (ch === 0x5F) || // $ (dollar) and _ (underscore)\r\n        (ch >= 0x41 && ch <= 0x5A) || // A..Z\r\n        (ch >= 0x61 && ch <= 0x7A) || // a..z\r\n        (ch === 0x5C) || // \\ (backslash)\r\n        ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\r\n}\r\nfunction isIdentifierPart(ch) {\r\n    return (ch === 0x24) || (ch === 0x5F) || // $ (dollar) and _ (underscore)\r\n        (ch >= 0x41 && ch <= 0x5A) || // A..Z\r\n        (ch >= 0x61 && ch <= 0x7A) || // a..z\r\n        (ch >= 0x30 && ch <= 0x39) || // 0..9\r\n        (ch === 0x5C) || // \\ (backslash)\r\n        ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\r\n}\r\n// 7.6.1.2 Future Reserved Words\r\nfunction isFutureReservedWord(id) {\r\n    switch (id) {\r\n        case 'class':\r\n        case 'enum':\r\n        case 'export':\r\n        case 'extends':\r\n        case 'import':\r\n        case 'super':\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isStrictModeReservedWord(id) {\r\n    switch (id) {\r\n        case 'implements':\r\n        case 'interface':\r\n        case 'package':\r\n        case 'private':\r\n        case 'protected':\r\n        case 'public':\r\n        case 'static':\r\n        case 'yield':\r\n        case 'let':\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isRestrictedWord(id) {\r\n    return id === 'eval' || id === 'arguments';\r\n}\r\n// 7.6.1.1 Keywords\r\nfunction isKeyword(id) {\r\n    if (strict && isStrictModeReservedWord(id)) {\r\n        return true;\r\n    }\r\n    // 'const' is specialized as Keyword in V8.\r\n    // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\r\n    // Some others are from future reserved words.\r\n    switch (id.length) {\r\n        case 2:\r\n            return (id === 'if') || (id === 'in') || (id === 'do');\r\n        case 3:\r\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\r\n                (id === 'try') || (id === 'let');\r\n        case 4:\r\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\r\n                (id === 'void') || (id === 'with') || (id === 'enum');\r\n        case 5:\r\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\r\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\r\n                (id === 'class') || (id === 'super');\r\n        case 6:\r\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\r\n                (id === 'switch') || (id === 'export') || (id === 'import');\r\n        case 7:\r\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\r\n        case 8:\r\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\r\n        case 10:\r\n            return (id === 'instanceof');\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n// 7.4 Comments\r\nfunction addComment(type, value, start, end, loc) {\r\n    var comment, attacher;\r\n    assert(typeof start === 'number', 'Comment must have valid position');\r\n    // Because the way the actual token is scanned, often the comments\r\n    // (if any) are skipped twice during the lexical analysis.\r\n    // Thus, we need to skip adding a comment if the comment array already\r\n    // handled it.\r\n    if (state.lastCommentStart >= start) {\r\n        return;\r\n    }\r\n    state.lastCommentStart = start;\r\n    comment = {\r\n        type: type,\r\n        value: value\r\n    };\r\n    if (extra.range) {\r\n        comment.range = [start, end];\r\n    }\r\n    if (extra.loc) {\r\n        comment.loc = loc;\r\n    }\r\n    extra.comments.push(comment);\r\n    if (extra.attachComment) {\r\n        extra.leadingComments.push(comment);\r\n        extra.trailingComments.push(comment);\r\n    }\r\n}\r\nfunction skipSingleLineComment(offset) {\r\n    var start, loc, ch, comment;\r\n    start = index - offset;\r\n    loc = {\r\n        start: {\r\n            line: lineNumber,\r\n            column: index - lineStart - offset\r\n        }\r\n    };\r\n    while (index < length) {\r\n        ch = source.charCodeAt(index);\r\n        ++index;\r\n        if (isLineTerminator(ch)) {\r\n            if (extra.comments) {\r\n                comment = source.slice(start + offset, index - 1);\r\n                loc.end = {\r\n                    line: lineNumber,\r\n                    column: index - lineStart - 1\r\n                };\r\n                addComment('Line', comment, start, index - 1, loc);\r\n            }\r\n            if (ch === 13 && source.charCodeAt(index) === 10) {\r\n                ++index;\r\n            }\r\n            ++lineNumber;\r\n            lineStart = index;\r\n            return;\r\n        }\r\n    }\r\n    if (extra.comments) {\r\n        comment = source.slice(start + offset, index);\r\n        loc.end = {\r\n            line: lineNumber,\r\n            column: index - lineStart\r\n        };\r\n        addComment('Line', comment, start, index, loc);\r\n    }\r\n}\r\nfunction skipMultiLineComment() {\r\n    var start, loc, ch, comment;\r\n    if (extra.comments) {\r\n        start = index - 2;\r\n        loc = {\r\n            start: {\r\n                line: lineNumber,\r\n                column: index - lineStart - 2\r\n            }\r\n        };\r\n    }\r\n    while (index < length) {\r\n        ch = source.charCodeAt(index);\r\n        if (isLineTerminator(ch)) {\r\n            if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\r\n                ++index;\r\n            }\r\n            ++lineNumber;\r\n            ++index;\r\n            lineStart = index;\r\n            if (index >= length) {\r\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n            }\r\n        }\r\n        else if (ch === 0x2A) {\r\n            // Block comment ends with '*/'.\r\n            if (source.charCodeAt(index + 1) === 0x2F) {\r\n                ++index;\r\n                ++index;\r\n                if (extra.comments) {\r\n                    comment = source.slice(start + 2, index - 2);\r\n                    loc.end = {\r\n                        line: lineNumber,\r\n                        column: index - lineStart\r\n                    };\r\n                    addComment('Block', comment, start, index, loc);\r\n                }\r\n                return;\r\n            }\r\n            ++index;\r\n        }\r\n        else {\r\n            ++index;\r\n        }\r\n    }\r\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n}\r\nfunction skipComment() {\r\n    var ch, start;\r\n    start = (index === 0);\r\n    while (index < length) {\r\n        ch = source.charCodeAt(index);\r\n        if (isWhiteSpace(ch)) {\r\n            ++index;\r\n        }\r\n        else if (isLineTerminator(ch)) {\r\n            ++index;\r\n            if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\r\n                ++index;\r\n            }\r\n            ++lineNumber;\r\n            lineStart = index;\r\n            start = true;\r\n        }\r\n        else if (ch === 0x2F) { // U+002F is '/'\r\n            ch = source.charCodeAt(index + 1);\r\n            if (ch === 0x2F) {\r\n                ++index;\r\n                ++index;\r\n                skipSingleLineComment(2);\r\n                start = true;\r\n            }\r\n            else if (ch === 0x2A) { // U+002A is '*'\r\n                ++index;\r\n                ++index;\r\n                skipMultiLineComment();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        else if (start && ch === 0x2D) { // U+002D is '-'\r\n            // U+003E is '>'\r\n            if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\r\n                // '-->' is a single-line comment\r\n                index += 3;\r\n                skipSingleLineComment(3);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        else if (ch === 0x3C) { // U+003C is '<'\r\n            if (source.slice(index + 1, index + 4) === '!--') {\r\n                ++index; // `<`\r\n                ++index; // `!`\r\n                ++index; // `-`\r\n                ++index; // `-`\r\n                skipSingleLineComment(4);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction scanHexEscape(prefix) {\r\n    var i, len, ch, code = 0;\r\n    len = (prefix === 'u') ? 4 : 2;\r\n    for (i = 0; i < len; ++i) {\r\n        if (index < length && isHexDigit(source[index])) {\r\n            ch = source[index++];\r\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    return String.fromCharCode(code);\r\n}\r\nfunction getEscapedIdentifier() {\r\n    var ch, id;\r\n    ch = source.charCodeAt(index++);\r\n    id = String.fromCharCode(ch);\r\n    // '\\u' (U+005C, U+0075) denotes an escaped character.\r\n    if (ch === 0x5C) {\r\n        if (source.charCodeAt(index) !== 0x75) {\r\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n        }\r\n        ++index;\r\n        ch = scanHexEscape('u');\r\n        if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\r\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n        }\r\n        id = ch;\r\n    }\r\n    while (index < length) {\r\n        ch = source.charCodeAt(index);\r\n        if (!isIdentifierPart(ch)) {\r\n            break;\r\n        }\r\n        ++index;\r\n        id += String.fromCharCode(ch);\r\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\r\n        if (ch === 0x5C) {\r\n            id = id.substr(0, id.length - 1);\r\n            if (source.charCodeAt(index) !== 0x75) {\r\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n            }\r\n            ++index;\r\n            ch = scanHexEscape('u');\r\n            if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\r\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n            }\r\n            id += ch;\r\n        }\r\n    }\r\n    return id;\r\n}\r\nfunction getIdentifier() {\r\n    var start, ch;\r\n    start = index++;\r\n    while (index < length) {\r\n        ch = source.charCodeAt(index);\r\n        if (ch === 0x5C) {\r\n            // Blackslash (U+005C) marks Unicode escape sequence.\r\n            index = start;\r\n            return getEscapedIdentifier();\r\n        }\r\n        if (isIdentifierPart(ch)) {\r\n            ++index;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return source.slice(start, index);\r\n}\r\nfunction scanIdentifier() {\r\n    var start, id, type;\r\n    start = index;\r\n    // Backslash (U+005C) starts an escaped character.\r\n    id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\r\n    // There is no keyword or literal with only one character.\r\n    // Thus, it must be an identifier.\r\n    if (id.length === 1) {\r\n        type = Token.Identifier;\r\n    }\r\n    else if (isKeyword(id)) {\r\n        type = Token.Keyword;\r\n    }\r\n    else if (id === 'null') {\r\n        type = Token.NullLiteral;\r\n    }\r\n    else if (id === 'true' || id === 'false') {\r\n        type = Token.BooleanLiteral;\r\n    }\r\n    else {\r\n        type = Token.Identifier;\r\n    }\r\n    return {\r\n        type: type,\r\n        value: id,\r\n        lineNumber: lineNumber,\r\n        lineStart: lineStart,\r\n        start: start,\r\n        end: index\r\n    };\r\n}\r\n// 7.7 Punctuators\r\nfunction scanPunctuator() {\r\n    var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;\r\n    switch (code) {\r\n        // Check for most common single-character punctuators.\r\n        case 0x2E: // . dot\r\n        case 0x28: // ( open bracket\r\n        case 0x29: // ) close bracket\r\n        case 0x3B: // ; semicolon\r\n        case 0x2C: // , comma\r\n        case 0x7B: // { open curly brace\r\n        case 0x7D: // } close curly brace\r\n        case 0x5B: // [\r\n        case 0x5D: // ]\r\n        case 0x3A: // :\r\n        case 0x3F: // ?\r\n        case 0x7E: // ~\r\n            ++index;\r\n            if (extra.tokenize) {\r\n                if (code === 0x28) {\r\n                    extra.openParenToken = extra.tokens.length;\r\n                }\r\n                else if (code === 0x7B) {\r\n                    extra.openCurlyToken = extra.tokens.length;\r\n                }\r\n            }\r\n            return {\r\n                type: Token.Punctuator,\r\n                value: String.fromCharCode(code),\r\n                lineNumber: lineNumber,\r\n                lineStart: lineStart,\r\n                start: start,\r\n                end: index\r\n            };\r\n        default:\r\n            code2 = source.charCodeAt(index + 1);\r\n            // '=' (U+003D) marks an assignment or comparison operator.\r\n            if (code2 === 0x3D) {\r\n                switch (code) {\r\n                    case 0x2B: // +\r\n                    case 0x2D: // -\r\n                    case 0x2F: // /\r\n                    case 0x3C: // <\r\n                    case 0x3E: // >\r\n                    case 0x5E: // ^\r\n                    case 0x7C: // |\r\n                    case 0x25: // %\r\n                    case 0x26: // &\r\n                    case 0x2A: // *\r\n                        index += 2;\r\n                        return {\r\n                            type: Token.Punctuator,\r\n                            value: String.fromCharCode(code) + String.fromCharCode(code2),\r\n                            lineNumber: lineNumber,\r\n                            lineStart: lineStart,\r\n                            start: start,\r\n                            end: index\r\n                        };\r\n                    case 0x21: // !\r\n                    case 0x3D: // =\r\n                        index += 2;\r\n                        // !== and ===\r\n                        if (source.charCodeAt(index) === 0x3D) {\r\n                            ++index;\r\n                        }\r\n                        return {\r\n                            type: Token.Punctuator,\r\n                            value: source.slice(start, index),\r\n                            lineNumber: lineNumber,\r\n                            lineStart: lineStart,\r\n                            start: start,\r\n                            end: index\r\n                        };\r\n                }\r\n            }\r\n    }\r\n    // 4-character punctuator: >>>=\r\n    ch4 = source.substr(index, 4);\r\n    if (ch4 === '>>>=') {\r\n        index += 4;\r\n        return {\r\n            type: Token.Punctuator,\r\n            value: ch4,\r\n            lineNumber: lineNumber,\r\n            lineStart: lineStart,\r\n            start: start,\r\n            end: index\r\n        };\r\n    }\r\n    // 3-character punctuators: === !== >>> <<= >>=\r\n    ch3 = ch4.substr(0, 3);\r\n    if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\r\n        index += 3;\r\n        return {\r\n            type: Token.Punctuator,\r\n            value: ch3,\r\n            lineNumber: lineNumber,\r\n            lineStart: lineStart,\r\n            start: start,\r\n            end: index\r\n        };\r\n    }\r\n    // Other 2-character punctuators: ++ -- << >> && ||\r\n    ch2 = ch3.substr(0, 2);\r\n    if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\r\n        index += 2;\r\n        return {\r\n            type: Token.Punctuator,\r\n            value: ch2,\r\n            lineNumber: lineNumber,\r\n            lineStart: lineStart,\r\n            start: start,\r\n            end: index\r\n        };\r\n    }\r\n    // 1-character punctuators: < > = ! + - * % & | ^ /\r\n    if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\r\n        ++index;\r\n        return {\r\n            type: Token.Punctuator,\r\n            value: ch1,\r\n            lineNumber: lineNumber,\r\n            lineStart: lineStart,\r\n            start: start,\r\n            end: index\r\n        };\r\n    }\r\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n}\r\n// 7.8.3 Numeric Literals\r\nfunction scanHexLiteral(start) {\r\n    var number = '';\r\n    while (index < length) {\r\n        if (!isHexDigit(source[index])) {\r\n            break;\r\n        }\r\n        number += source[index++];\r\n    }\r\n    if (number.length === 0) {\r\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n    }\r\n    if (isIdentifierStart(source.charCodeAt(index))) {\r\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n    }\r\n    return {\r\n        type: Token.NumericLiteral,\r\n        value: parseInt('0x' + number, 16),\r\n        lineNumber: lineNumber,\r\n        lineStart: lineStart,\r\n        start: start,\r\n        end: index\r\n    };\r\n}\r\nfunction scanOctalLiteral(start) {\r\n    var number = '0' + source[index++];\r\n    while (index < length) {\r\n        if (!isOctalDigit(source[index])) {\r\n            break;\r\n        }\r\n        number += source[index++];\r\n    }\r\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\r\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n    }\r\n    return {\r\n        type: Token.NumericLiteral,\r\n        value: parseInt(number, 8),\r\n        octal: true,\r\n        lineNumber: lineNumber,\r\n        lineStart: lineStart,\r\n        start: start,\r\n        end: index\r\n    };\r\n}\r\nfunction scanNumericLiteral() {\r\n    var number, start, ch;\r\n    ch = source[index];\r\n    assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');\r\n    start = index;\r\n    number = '';\r\n    if (ch !== '.') {\r\n        number = source[index++];\r\n        ch = source[index];\r\n        // Hex number starts with '0x'.\r\n        // Octal number starts with '0'.\r\n        if (number === '0') {\r\n            if (ch === 'x' || ch === 'X') {\r\n                ++index;\r\n                return scanHexLiteral(start);\r\n            }\r\n            if (isOctalDigit(ch)) {\r\n                return scanOctalLiteral(start);\r\n            }\r\n            // decimal number starts with '0' such as '09' is illegal.\r\n            if (ch && isDecimalDigit(ch.charCodeAt(0))) {\r\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n            }\r\n        }\r\n        while (isDecimalDigit(source.charCodeAt(index))) {\r\n            number += source[index++];\r\n        }\r\n        ch = source[index];\r\n    }\r\n    if (ch === '.') {\r\n        number += source[index++];\r\n        while (isDecimalDigit(source.charCodeAt(index))) {\r\n            number += source[index++];\r\n        }\r\n        ch = source[index];\r\n    }\r\n    if (ch === 'e' || ch === 'E') {\r\n        number += source[index++];\r\n        ch = source[index];\r\n        if (ch === '+' || ch === '-') {\r\n            number += source[index++];\r\n        }\r\n        if (isDecimalDigit(source.charCodeAt(index))) {\r\n            while (isDecimalDigit(source.charCodeAt(index))) {\r\n                number += source[index++];\r\n            }\r\n        }\r\n        else {\r\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n        }\r\n    }\r\n    if (isIdentifierStart(source.charCodeAt(index))) {\r\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n    }\r\n    return {\r\n        type: Token.NumericLiteral,\r\n        value: parseFloat(number),\r\n        lineNumber: lineNumber,\r\n        lineStart: lineStart,\r\n        start: start,\r\n        end: index\r\n    };\r\n}\r\n// 7.8.4 String Literals\r\nfunction scanStringLiteral() {\r\n    var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\r\n    startLineNumber = lineNumber;\r\n    startLineStart = lineStart;\r\n    quote = source[index];\r\n    assert((quote === '\\'' || quote === '\"'), 'String literal must starts with a quote');\r\n    start = index;\r\n    ++index;\r\n    while (index < length) {\r\n        ch = source[index++];\r\n        if (ch === quote) {\r\n            quote = '';\r\n            break;\r\n        }\r\n        else if (ch === '\\\\') {\r\n            ch = source[index++];\r\n            if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\r\n                switch (ch) {\r\n                    case 'u':\r\n                    case 'x':\r\n                        restore = index;\r\n                        unescaped = scanHexEscape(ch);\r\n                        if (unescaped) {\r\n                            str += unescaped;\r\n                        }\r\n                        else {\r\n                            index = restore;\r\n                            str += ch;\r\n                        }\r\n                        break;\r\n                    case 'n':\r\n                        str += '\\n';\r\n                        break;\r\n                    case 'r':\r\n                        str += '\\r';\r\n                        break;\r\n                    case 't':\r\n                        str += '\\t';\r\n                        break;\r\n                    case 'b':\r\n                        str += '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        str += '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        str += '\\x0B';\r\n                        break;\r\n                    default:\r\n                        if (isOctalDigit(ch)) {\r\n                            code = '01234567'.indexOf(ch);\r\n                            // \\0 is not octal escape sequence\r\n                            if (code !== 0) {\r\n                                octal = true;\r\n                            }\r\n                            if (index < length && isOctalDigit(source[index])) {\r\n                                octal = true;\r\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\r\n                                // 3 digits are only allowed when string starts\r\n                                // with 0, 1, 2, 3\r\n                                if ('0123'.indexOf(ch) >= 0 &&\r\n                                    index < length &&\r\n                                    isOctalDigit(source[index])) {\r\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\r\n                                }\r\n                            }\r\n                            str += String.fromCharCode(code);\r\n                        }\r\n                        else {\r\n                            str += ch;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                ++lineNumber;\r\n                if (ch === '\\r' && source[index] === '\\n') {\r\n                    ++index;\r\n                }\r\n                lineStart = index;\r\n            }\r\n        }\r\n        else if (isLineTerminator(ch.charCodeAt(0))) {\r\n            break;\r\n        }\r\n        else {\r\n            str += ch;\r\n        }\r\n    }\r\n    if (quote !== '') {\r\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n    }\r\n    return {\r\n        type: Token.StringLiteral,\r\n        value: str,\r\n        octal: octal,\r\n        startLineNumber: startLineNumber,\r\n        startLineStart: startLineStart,\r\n        lineNumber: lineNumber,\r\n        lineStart: lineStart,\r\n        start: start,\r\n        end: index\r\n    };\r\n}\r\nfunction testRegExp(pattern, flags) {\r\n    var value;\r\n    try {\r\n        value = new RegExp(pattern, flags);\r\n    }\r\n    catch (e) {\r\n        throwError({}, Messages.InvalidRegExp);\r\n    }\r\n    return value;\r\n}\r\nfunction scanRegExpBody() {\r\n    var ch, str, classMarker, terminated, body;\r\n    ch = source[index];\r\n    assert(ch === '/', 'Regular expression literal must start with a slash');\r\n    str = source[index++];\r\n    classMarker = false;\r\n    terminated = false;\r\n    while (index < length) {\r\n        ch = source[index++];\r\n        str += ch;\r\n        if (ch === '\\\\') {\r\n            ch = source[index++];\r\n            // ECMA-262 7.8.5\r\n            if (isLineTerminator(ch.charCodeAt(0))) {\r\n                throwError({}, Messages.UnterminatedRegExp);\r\n            }\r\n            str += ch;\r\n        }\r\n        else if (isLineTerminator(ch.charCodeAt(0))) {\r\n            throwError({}, Messages.UnterminatedRegExp);\r\n        }\r\n        else if (classMarker) {\r\n            if (ch === ']') {\r\n                classMarker = false;\r\n            }\r\n        }\r\n        else {\r\n            if (ch === '/') {\r\n                terminated = true;\r\n                break;\r\n            }\r\n            else if (ch === '[') {\r\n                classMarker = true;\r\n            }\r\n        }\r\n    }\r\n    if (!terminated) {\r\n        throwError({}, Messages.UnterminatedRegExp);\r\n    }\r\n    // Exclude leading and trailing slash.\r\n    body = str.substr(1, str.length - 2);\r\n    return {\r\n        value: body,\r\n        literal: str\r\n    };\r\n}\r\nfunction scanRegExpFlags() {\r\n    var ch, str, flags, restore;\r\n    str = '';\r\n    flags = '';\r\n    while (index < length) {\r\n        ch = source[index];\r\n        if (!isIdentifierPart(ch.charCodeAt(0))) {\r\n            break;\r\n        }\r\n        ++index;\r\n        if (ch === '\\\\' && index < length) {\r\n            ch = source[index];\r\n            if (ch === 'u') {\r\n                ++index;\r\n                restore = index;\r\n                ch = scanHexEscape('u');\r\n                if (ch) {\r\n                    flags += ch;\r\n                    for (str += '\\\\u'; restore < index; ++restore) {\r\n                        str += source[restore];\r\n                    }\r\n                }\r\n                else {\r\n                    index = restore;\r\n                    flags += 'u';\r\n                    str += '\\\\u';\r\n                }\r\n                throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n            }\r\n            else {\r\n                str += '\\\\';\r\n                throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\r\n            }\r\n        }\r\n        else {\r\n            flags += ch;\r\n            str += ch;\r\n        }\r\n    }\r\n    return {\r\n        value: flags,\r\n        literal: str\r\n    };\r\n}\r\nfunction scanRegExp() {\r\n    var start, body, flags, pattern, value;\r\n    lookahead = null;\r\n    skipComment();\r\n    start = index;\r\n    body = scanRegExpBody();\r\n    flags = scanRegExpFlags();\r\n    value = testRegExp(body.value, flags.value);\r\n    if (extra.tokenize) {\r\n        return {\r\n            type: Token.RegularExpression,\r\n            value: value,\r\n            lineNumber: lineNumber,\r\n            lineStart: lineStart,\r\n            start: start,\r\n            end: index\r\n        };\r\n    }\r\n    return {\r\n        literal: body.literal + flags.literal,\r\n        value: value,\r\n        start: start,\r\n        end: index\r\n    };\r\n}\r\nfunction collectRegex() {\r\n    var pos, loc, regex, token;\r\n    skipComment();\r\n    pos = index;\r\n    loc = {\r\n        start: {\r\n            line: lineNumber,\r\n            column: index - lineStart\r\n        }\r\n    };\r\n    regex = scanRegExp();\r\n    loc.end = {\r\n        line: lineNumber,\r\n        column: index - lineStart\r\n    };\r\n    /* istanbul ignore next */\r\n    if (!extra.tokenize) {\r\n        // Pop the previous token, which is likely '/' or '/='\r\n        if (extra.tokens.length > 0) {\r\n            token = extra.tokens[extra.tokens.length - 1];\r\n            if (token.range[0] === pos && token.type === 'Punctuator') {\r\n                if (token.value === '/' || token.value === '/=') {\r\n                    extra.tokens.pop();\r\n                }\r\n            }\r\n        }\r\n        extra.tokens.push({\r\n            type: 'RegularExpression',\r\n            value: regex.literal,\r\n            range: [pos, index],\r\n            loc: loc\r\n        });\r\n    }\r\n    return regex;\r\n}\r\nfunction isIdentifierName(token) {\r\n    return token.type === Token.Identifier ||\r\n        token.type === Token.Keyword ||\r\n        token.type === Token.BooleanLiteral ||\r\n        token.type === Token.NullLiteral;\r\n}\r\nfunction advanceSlash() {\r\n    var prevToken, checkToken;\r\n    // Using the following algorithm:\r\n    // https://github.com/mozilla/sweet.js/wiki/design\r\n    prevToken = extra.tokens[extra.tokens.length - 1];\r\n    if (!prevToken) {\r\n        // Nothing before that: it cannot be a division.\r\n        return collectRegex();\r\n    }\r\n    if (prevToken.type === 'Punctuator') {\r\n        if (prevToken.value === ']') {\r\n            return scanPunctuator();\r\n        }\r\n        if (prevToken.value === ')') {\r\n            checkToken = extra.tokens[extra.openParenToken - 1];\r\n            if (checkToken &&\r\n                checkToken.type === 'Keyword' &&\r\n                (checkToken.value === 'if' ||\r\n                    checkToken.value === 'while' ||\r\n                    checkToken.value === 'for' ||\r\n                    checkToken.value === 'with')) {\r\n                return collectRegex();\r\n            }\r\n            return scanPunctuator();\r\n        }\r\n        if (prevToken.value === '}') {\r\n            // Dividing a function by anything makes little sense,\r\n            // but we have to check for that.\r\n            if (extra.tokens[extra.openCurlyToken - 3] &&\r\n                extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\r\n                // Anonymous function.\r\n                checkToken = extra.tokens[extra.openCurlyToken - 4];\r\n                if (!checkToken) {\r\n                    return scanPunctuator();\r\n                }\r\n            }\r\n            else if (extra.tokens[extra.openCurlyToken - 4] &&\r\n                extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\r\n                // Named function.\r\n                checkToken = extra.tokens[extra.openCurlyToken - 5];\r\n                if (!checkToken) {\r\n                    return collectRegex();\r\n                }\r\n            }\r\n            else {\r\n                return scanPunctuator();\r\n            }\r\n            // checkToken determines whether the function is\r\n            // a declaration or an expression.\r\n            if (FnExprTokens.indexOf(checkToken.value) >= 0) {\r\n                // It is an expression.\r\n                return scanPunctuator();\r\n            }\r\n            // It is a declaration.\r\n            return collectRegex();\r\n        }\r\n        return collectRegex();\r\n    }\r\n    if (prevToken.type === 'Keyword') {\r\n        return collectRegex();\r\n    }\r\n    return scanPunctuator();\r\n}\r\nfunction advance() {\r\n    var ch;\r\n    skipComment();\r\n    if (index >= length) {\r\n        return {\r\n            type: Token.EOF,\r\n            lineNumber: lineNumber,\r\n            lineStart: lineStart,\r\n            start: index,\r\n            end: index\r\n        };\r\n    }\r\n    ch = source.charCodeAt(index);\r\n    if (isIdentifierStart(ch)) {\r\n        return scanIdentifier();\r\n    }\r\n    // Very common: ( and ) and ;\r\n    if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\r\n        return scanPunctuator();\r\n    }\r\n    // String literal starts with single quote (U+0027) or double quote (U+0022).\r\n    if (ch === 0x27 || ch === 0x22) {\r\n        return scanStringLiteral();\r\n    }\r\n    // Dot (.) U+002E can also start a floating-point number, hence the need\r\n    // to check the next character.\r\n    if (ch === 0x2E) {\r\n        if (isDecimalDigit(source.charCodeAt(index + 1))) {\r\n            return scanNumericLiteral();\r\n        }\r\n        return scanPunctuator();\r\n    }\r\n    if (isDecimalDigit(ch)) {\r\n        return scanNumericLiteral();\r\n    }\r\n    // Slash (/) U+002F can also start a regex.\r\n    if (extra.tokenize && ch === 0x2F) {\r\n        return advanceSlash();\r\n    }\r\n    return scanPunctuator();\r\n}\r\nfunction collectToken() {\r\n    var loc, token, range, value;\r\n    skipComment();\r\n    loc = {\r\n        start: {\r\n            line: lineNumber,\r\n            column: index - lineStart\r\n        }\r\n    };\r\n    token = advance();\r\n    loc.end = {\r\n        line: lineNumber,\r\n        column: index - lineStart\r\n    };\r\n    if (token.type !== Token.EOF) {\r\n        value = source.slice(token.start, token.end);\r\n        extra.tokens.push({\r\n            type: TokenName[token.type],\r\n            value: value,\r\n            range: [token.start, token.end],\r\n            loc: loc\r\n        });\r\n    }\r\n    return token;\r\n}\r\nfunction lex() {\r\n    var token;\r\n    token = lookahead;\r\n    index = token.end;\r\n    lineNumber = token.lineNumber;\r\n    lineStart = token.lineStart;\r\n    lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\r\n    index = token.end;\r\n    lineNumber = token.lineNumber;\r\n    lineStart = token.lineStart;\r\n    return token;\r\n}\r\nfunction peek() {\r\n    var pos, line, start;\r\n    pos = index;\r\n    line = lineNumber;\r\n    start = lineStart;\r\n    lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\r\n    index = pos;\r\n    lineNumber = line;\r\n    lineStart = start;\r\n}\r\nfunction Position(line, column) {\r\n    this.line = line;\r\n    this.column = column;\r\n}\r\nfunction SourceLocation(startLine, startColumn, line, column) {\r\n    this.start = new Position(startLine, startColumn);\r\n    this.end = new Position(line, column);\r\n}\r\nSyntaxTreeDelegate = {\r\n    name: 'SyntaxTree',\r\n    processComment: function (node) {\r\n        var lastChild, trailingComments;\r\n        if (node.type === Syntax.Program) {\r\n            if (node.body.length > 0) {\r\n                return;\r\n            }\r\n        }\r\n        if (extra.trailingComments.length > 0) {\r\n            if (extra.trailingComments[0].range[0] >= node.range[1]) {\r\n                trailingComments = extra.trailingComments;\r\n                extra.trailingComments = [];\r\n            }\r\n            else {\r\n                extra.trailingComments.length = 0;\r\n            }\r\n        }\r\n        else {\r\n            if (extra.bottomRightStack.length > 0 &&\r\n                extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&\r\n                extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {\r\n                trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\r\n                delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\r\n            }\r\n        }\r\n        // Eating the stack.\r\n        while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {\r\n            lastChild = extra.bottomRightStack.pop();\r\n        }\r\n        if (lastChild) {\r\n            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\r\n                node.leadingComments = lastChild.leadingComments;\r\n                delete lastChild.leadingComments;\r\n            }\r\n        }\r\n        else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\r\n            node.leadingComments = extra.leadingComments;\r\n            extra.leadingComments = [];\r\n        }\r\n        if (trailingComments) {\r\n            node.trailingComments = trailingComments;\r\n        }\r\n        extra.bottomRightStack.push(node);\r\n    },\r\n    markEnd: function (node, startToken) {\r\n        if (extra.range) {\r\n            node.range = [startToken.start, index];\r\n        }\r\n        if (extra.loc) {\r\n            node.loc = new SourceLocation(startToken.startLineNumber === undefined ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === undefined ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);\r\n            this.postProcess(node);\r\n        }\r\n        if (extra.attachComment) {\r\n            this.processComment(node);\r\n        }\r\n        return node;\r\n    },\r\n    postProcess: function (node) {\r\n        if (extra.source) {\r\n            node.loc.source = extra.source;\r\n        }\r\n        return node;\r\n    },\r\n    createArrayExpression: function (elements) {\r\n        return {\r\n            type: Syntax.ArrayExpression,\r\n            elements: elements\r\n        };\r\n    },\r\n    createAssignmentExpression: function (operator, left, right) {\r\n        return {\r\n            type: Syntax.AssignmentExpression,\r\n            operator: operator,\r\n            left: left,\r\n            right: right\r\n        };\r\n    },\r\n    createBinaryExpression: function (operator, left, right) {\r\n        var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\r\n            Syntax.BinaryExpression;\r\n        return {\r\n            type: type,\r\n            operator: operator,\r\n            left: left,\r\n            right: right\r\n        };\r\n    },\r\n    createBlockStatement: function (body) {\r\n        return {\r\n            type: Syntax.BlockStatement,\r\n            body: body\r\n        };\r\n    },\r\n    createBreakStatement: function (label) {\r\n        return {\r\n            type: Syntax.BreakStatement,\r\n            label: label\r\n        };\r\n    },\r\n    createCallExpression: function (callee, args) {\r\n        return {\r\n            type: Syntax.CallExpression,\r\n            callee: callee,\r\n            'arguments': args\r\n        };\r\n    },\r\n    createCatchClause: function (param, body) {\r\n        return {\r\n            type: Syntax.CatchClause,\r\n            param: param,\r\n            body: body\r\n        };\r\n    },\r\n    createConditionalExpression: function (test, consequent, alternate) {\r\n        return {\r\n            type: Syntax.ConditionalExpression,\r\n            test: test,\r\n            consequent: consequent,\r\n            alternate: alternate\r\n        };\r\n    },\r\n    createContinueStatement: function (label) {\r\n        return {\r\n            type: Syntax.ContinueStatement,\r\n            label: label\r\n        };\r\n    },\r\n    createDebuggerStatement: function () {\r\n        return {\r\n            type: Syntax.DebuggerStatement\r\n        };\r\n    },\r\n    createDoWhileStatement: function (body, test) {\r\n        return {\r\n            type: Syntax.DoWhileStatement,\r\n            body: body,\r\n            test: test\r\n        };\r\n    },\r\n    createEmptyStatement: function () {\r\n        return {\r\n            type: Syntax.EmptyStatement\r\n        };\r\n    },\r\n    createExpressionStatement: function (expression) {\r\n        return {\r\n            type: Syntax.ExpressionStatement,\r\n            expression: expression\r\n        };\r\n    },\r\n    createForStatement: function (init, test, update, body) {\r\n        return {\r\n            type: Syntax.ForStatement,\r\n            init: init,\r\n            test: test,\r\n            update: update,\r\n            body: body\r\n        };\r\n    },\r\n    createForInStatement: function (left, right, body) {\r\n        return {\r\n            type: Syntax.ForInStatement,\r\n            left: left,\r\n            right: right,\r\n            body: body,\r\n            each: false\r\n        };\r\n    },\r\n    createFunctionDeclaration: function (id, params, defaults, body) {\r\n        return {\r\n            type: Syntax.FunctionDeclaration,\r\n            id: id,\r\n            params: params,\r\n            defaults: defaults,\r\n            body: body,\r\n            rest: null,\r\n            generator: false,\r\n            expression: false\r\n        };\r\n    },\r\n    createFunctionExpression: function (id, params, defaults, body) {\r\n        return {\r\n            type: Syntax.FunctionExpression,\r\n            id: id,\r\n            params: params,\r\n            defaults: defaults,\r\n            body: body,\r\n            rest: null,\r\n            generator: false,\r\n            expression: false\r\n        };\r\n    },\r\n    createIdentifier: function (name) {\r\n        return {\r\n            type: Syntax.Identifier,\r\n            name: name\r\n        };\r\n    },\r\n    createIfStatement: function (test, consequent, alternate) {\r\n        return {\r\n            type: Syntax.IfStatement,\r\n            test: test,\r\n            consequent: consequent,\r\n            alternate: alternate\r\n        };\r\n    },\r\n    createLabeledStatement: function (label, body) {\r\n        return {\r\n            type: Syntax.LabeledStatement,\r\n            label: label,\r\n            body: body\r\n        };\r\n    },\r\n    createLiteral: function (token) {\r\n        return {\r\n            type: Syntax.Literal,\r\n            value: token.value,\r\n            raw: source.slice(token.start, token.end)\r\n        };\r\n    },\r\n    createMemberExpression: function (accessor, object, property) {\r\n        return {\r\n            type: Syntax.MemberExpression,\r\n            computed: accessor === '[',\r\n            object: object,\r\n            property: property\r\n        };\r\n    },\r\n    createNewExpression: function (callee, args) {\r\n        return {\r\n            type: Syntax.NewExpression,\r\n            callee: callee,\r\n            'arguments': args\r\n        };\r\n    },\r\n    createObjectExpression: function (properties) {\r\n        return {\r\n            type: Syntax.ObjectExpression,\r\n            properties: properties\r\n        };\r\n    },\r\n    createPostfixExpression: function (operator, argument) {\r\n        return {\r\n            type: Syntax.UpdateExpression,\r\n            operator: operator,\r\n            argument: argument,\r\n            prefix: false\r\n        };\r\n    },\r\n    createProgram: function (body) {\r\n        return {\r\n            type: Syntax.Program,\r\n            body: body\r\n        };\r\n    },\r\n    createProperty: function (kind, key, value) {\r\n        return {\r\n            type: Syntax.Property,\r\n            key: key,\r\n            value: value,\r\n            kind: kind\r\n        };\r\n    },\r\n    createReturnStatement: function (argument) {\r\n        return {\r\n            type: Syntax.ReturnStatement,\r\n            argument: argument\r\n        };\r\n    },\r\n    createSequenceExpression: function (expressions) {\r\n        return {\r\n            type: Syntax.SequenceExpression,\r\n            expressions: expressions\r\n        };\r\n    },\r\n    createSwitchCase: function (test, consequent) {\r\n        return {\r\n            type: Syntax.SwitchCase,\r\n            test: test,\r\n            consequent: consequent\r\n        };\r\n    },\r\n    createSwitchStatement: function (discriminant, cases) {\r\n        return {\r\n            type: Syntax.SwitchStatement,\r\n            discriminant: discriminant,\r\n            cases: cases\r\n        };\r\n    },\r\n    createThisExpression: function () {\r\n        return {\r\n            type: Syntax.ThisExpression\r\n        };\r\n    },\r\n    createThrowStatement: function (argument) {\r\n        return {\r\n            type: Syntax.ThrowStatement,\r\n            argument: argument\r\n        };\r\n    },\r\n    createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\r\n        return {\r\n            type: Syntax.TryStatement,\r\n            block: block,\r\n            guardedHandlers: guardedHandlers,\r\n            handlers: handlers,\r\n            finalizer: finalizer\r\n        };\r\n    },\r\n    createUnaryExpression: function (operator, argument) {\r\n        if (operator === '++' || operator === '--') {\r\n            return {\r\n                type: Syntax.UpdateExpression,\r\n                operator: operator,\r\n                argument: argument,\r\n                prefix: true\r\n            };\r\n        }\r\n        return {\r\n            type: Syntax.UnaryExpression,\r\n            operator: operator,\r\n            argument: argument,\r\n            prefix: true\r\n        };\r\n    },\r\n    createVariableDeclaration: function (declarations, kind) {\r\n        return {\r\n            type: Syntax.VariableDeclaration,\r\n            declarations: declarations,\r\n            kind: kind\r\n        };\r\n    },\r\n    createVariableDeclarator: function (id, init) {\r\n        return {\r\n            type: Syntax.VariableDeclarator,\r\n            id: id,\r\n            init: init\r\n        };\r\n    },\r\n    createWhileStatement: function (test, body) {\r\n        return {\r\n            type: Syntax.WhileStatement,\r\n            test: test,\r\n            body: body\r\n        };\r\n    },\r\n    createWithStatement: function (object, body) {\r\n        return {\r\n            type: Syntax.WithStatement,\r\n            object: object,\r\n            body: body\r\n        };\r\n    }\r\n};\r\n// Return true if there is a line terminator before the next token.\r\nfunction peekLineTerminator() {\r\n    var pos, line, start, found;\r\n    pos = index;\r\n    line = lineNumber;\r\n    start = lineStart;\r\n    skipComment();\r\n    found = lineNumber !== line;\r\n    index = pos;\r\n    lineNumber = line;\r\n    lineStart = start;\r\n    return found;\r\n}\r\n// Throw an exception\r\nfunction throwError(token, messageFormat) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    var error, msg = messageFormat.replace(/%(\\d)/g, function (whole, index) {\r\n        assert(index < args.length, 'Message reference must be in range');\r\n        return args[index];\r\n    });\r\n    if (typeof token.lineNumber === 'number') {\r\n        error = new Error('Line ' + token.lineNumber + ': ' + msg);\r\n        error.index = token.start;\r\n        error.lineNumber = token.lineNumber;\r\n        error.column = token.start - lineStart + 1;\r\n    }\r\n    else {\r\n        error = new Error('Line ' + lineNumber + ': ' + msg);\r\n        error.index = index;\r\n        error.lineNumber = lineNumber;\r\n        error.column = index - lineStart + 1;\r\n    }\r\n    error.description = msg;\r\n    throw error;\r\n}\r\nfunction throwErrorTolerant() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    try {\r\n        throwError.apply(null, args);\r\n    }\r\n    catch (e) {\r\n        if (extra.errors) {\r\n            extra.errors.push(e);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n// Throw an exception because of the token.\r\nfunction throwUnexpected(token) {\r\n    if (token.type === Token.EOF) {\r\n        throwError(token, Messages.UnexpectedEOS);\r\n    }\r\n    if (token.type === Token.NumericLiteral) {\r\n        throwError(token, Messages.UnexpectedNumber);\r\n    }\r\n    if (token.type === Token.StringLiteral) {\r\n        throwError(token, Messages.UnexpectedString);\r\n    }\r\n    if (token.type === Token.Identifier) {\r\n        throwError(token, Messages.UnexpectedIdentifier);\r\n    }\r\n    if (token.type === Token.Keyword) {\r\n        if (isFutureReservedWord(token.value)) {\r\n            throwError(token, Messages.UnexpectedReserved);\r\n        }\r\n        else if (strict && isStrictModeReservedWord(token.value)) {\r\n            throwErrorTolerant(token, Messages.StrictReservedWord);\r\n            return;\r\n        }\r\n        throwError(token, Messages.UnexpectedToken, token.value);\r\n    }\r\n    // BooleanLiteral, NullLiteral, or Punctuator.\r\n    throwError(token, Messages.UnexpectedToken, token.value);\r\n}\r\n// Expect the next token to match the specified punctuator.\r\n// If not, an exception will be thrown.\r\nfunction expect(value) {\r\n    var token = lex();\r\n    if (token.type !== Token.Punctuator || token.value !== value) {\r\n        throwUnexpected(token);\r\n    }\r\n}\r\n// Expect the next token to match the specified keyword.\r\n// If not, an exception will be thrown.\r\nfunction expectKeyword(keyword) {\r\n    var token = lex();\r\n    if (token.type !== Token.Keyword || token.value !== keyword) {\r\n        throwUnexpected(token);\r\n    }\r\n}\r\n// Return true if the next token matches the specified punctuator.\r\nfunction match(value) {\r\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\r\n}\r\n// Return true if the next token matches the specified keyword\r\nfunction matchKeyword(keyword) {\r\n    return lookahead.type === Token.Keyword && lookahead.value === keyword;\r\n}\r\n// Return true if the next token is an assignment operator\r\nfunction matchAssign() {\r\n    var op;\r\n    if (lookahead.type !== Token.Punctuator) {\r\n        return false;\r\n    }\r\n    op = lookahead.value;\r\n    return op === '=' ||\r\n        op === '*=' ||\r\n        op === '/=' ||\r\n        op === '%=' ||\r\n        op === '+=' ||\r\n        op === '-=' ||\r\n        op === '<<=' ||\r\n        op === '>>=' ||\r\n        op === '>>>=' ||\r\n        op === '&=' ||\r\n        op === '^=' ||\r\n        op === '|=';\r\n}\r\nfunction consumeSemicolon() {\r\n    var line;\r\n    // Catch the very common case first: immediately a semicolon (U+003B).\r\n    if (source.charCodeAt(index) === 0x3B || match(';')) {\r\n        lex();\r\n        return;\r\n    }\r\n    line = lineNumber;\r\n    skipComment();\r\n    if (lineNumber !== line) {\r\n        return;\r\n    }\r\n    if (lookahead.type !== Token.EOF && !match('}')) {\r\n        throwUnexpected(lookahead);\r\n    }\r\n}\r\n// Return true if provided expression is LeftHandSideExpression\r\nfunction isLeftHandSide(expr) {\r\n    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\r\n}\r\n// 11.1.4 Array Initialiser\r\nfunction parseArrayInitialiser() {\r\n    var elements = [], startToken;\r\n    startToken = lookahead;\r\n    expect('[');\r\n    while (!match(']')) {\r\n        if (match(',')) {\r\n            lex();\r\n            elements.push(null);\r\n        }\r\n        else {\r\n            elements.push(parseAssignmentExpression());\r\n            if (!match(']')) {\r\n                expect(',');\r\n            }\r\n        }\r\n    }\r\n    lex();\r\n    return delegate.markEnd(delegate.createArrayExpression(elements), startToken);\r\n}\r\n// 11.1.5 Object Initialiser\r\nfunction parsePropertyFunction(param, first) {\r\n    var previousStrict, body, startToken;\r\n    previousStrict = strict;\r\n    startToken = lookahead;\r\n    body = parseFunctionSourceElements();\r\n    if (first && strict && isRestrictedWord(param[0].name)) {\r\n        throwErrorTolerant(first, Messages.StrictParamName);\r\n    }\r\n    strict = previousStrict;\r\n    return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);\r\n}\r\nfunction parseObjectPropertyKey() {\r\n    var token, startToken;\r\n    startToken = lookahead;\r\n    token = lex();\r\n    // Note: This function is called only from parseObjectProperty(), where\r\n    // EOF and Punctuator tokens are already filtered out.\r\n    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\r\n        if (strict && token.octal) {\r\n            throwErrorTolerant(token, Messages.StrictOctalLiteral);\r\n        }\r\n        return delegate.markEnd(delegate.createLiteral(token), startToken);\r\n    }\r\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\r\n}\r\nfunction parseObjectProperty() {\r\n    var token, key, id, value, param, startToken;\r\n    token = lookahead;\r\n    startToken = lookahead;\r\n    if (token.type === Token.Identifier) {\r\n        id = parseObjectPropertyKey();\r\n        // Property Assignment: Getter and Setter.\r\n        if (token.value === 'get' && !match(':')) {\r\n            key = parseObjectPropertyKey();\r\n            expect('(');\r\n            expect(')');\r\n            value = parsePropertyFunction([]);\r\n            return delegate.markEnd(delegate.createProperty('get', key, value), startToken);\r\n        }\r\n        if (token.value === 'set' && !match(':')) {\r\n            key = parseObjectPropertyKey();\r\n            expect('(');\r\n            token = lookahead;\r\n            if (token.type !== Token.Identifier) {\r\n                expect(')');\r\n                throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\r\n                value = parsePropertyFunction([]);\r\n            }\r\n            else {\r\n                param = [parseVariableIdentifier()];\r\n                expect(')');\r\n                value = parsePropertyFunction(param, token);\r\n            }\r\n            return delegate.markEnd(delegate.createProperty('set', key, value), startToken);\r\n        }\r\n        expect(':');\r\n        value = parseAssignmentExpression();\r\n        return delegate.markEnd(delegate.createProperty('init', id, value), startToken);\r\n    }\r\n    if (token.type === Token.EOF || token.type === Token.Punctuator) {\r\n        throwUnexpected(token);\r\n    }\r\n    else {\r\n        key = parseObjectPropertyKey();\r\n        expect(':');\r\n        value = parseAssignmentExpression();\r\n        return delegate.markEnd(delegate.createProperty('init', key, value), startToken);\r\n    }\r\n}\r\nfunction parseObjectInitialiser() {\r\n    var properties = [], property, name, key, kind, map = {}, toString = String, startToken;\r\n    startToken = lookahead;\r\n    expect('{');\r\n    while (!match('}')) {\r\n        property = parseObjectProperty();\r\n        if (property.key.type === Syntax.Identifier) {\r\n            name = property.key.name;\r\n        }\r\n        else {\r\n            name = toString(property.key.value);\r\n        }\r\n        kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\r\n        key = '$' + name;\r\n        if (Object.prototype.hasOwnProperty.call(map, key)) {\r\n            if (map[key] === PropertyKind.Data) {\r\n                if (strict && kind === PropertyKind.Data) {\r\n                    throwErrorTolerant({}, Messages.StrictDuplicateProperty);\r\n                }\r\n                else if (kind !== PropertyKind.Data) {\r\n                    throwErrorTolerant({}, Messages.AccessorDataProperty);\r\n                }\r\n            }\r\n            else {\r\n                if (kind === PropertyKind.Data) {\r\n                    throwErrorTolerant({}, Messages.AccessorDataProperty);\r\n                }\r\n                else if (map[key] & kind) {\r\n                    throwErrorTolerant({}, Messages.AccessorGetSet);\r\n                }\r\n            }\r\n            map[key] |= kind;\r\n        }\r\n        else {\r\n            map[key] = kind;\r\n        }\r\n        properties.push(property);\r\n        if (!match('}')) {\r\n            expect(',');\r\n        }\r\n    }\r\n    expect('}');\r\n    return delegate.markEnd(delegate.createObjectExpression(properties), startToken);\r\n}\r\n// 11.1.6 The Grouping Operator\r\nfunction parseGroupExpression() {\r\n    var expr;\r\n    expect('(');\r\n    expr = parseExpression();\r\n    expect(')');\r\n    return expr;\r\n}\r\n// 11.1 Primary Expressions\r\nfunction parsePrimaryExpression() {\r\n    var type, token, expr, startToken;\r\n    if (match('(')) {\r\n        return parseGroupExpression();\r\n    }\r\n    if (match('[')) {\r\n        return parseArrayInitialiser();\r\n    }\r\n    if (match('{')) {\r\n        return parseObjectInitialiser();\r\n    }\r\n    type = lookahead.type;\r\n    startToken = lookahead;\r\n    if (type === Token.Identifier) {\r\n        expr = delegate.createIdentifier(lex().value);\r\n    }\r\n    else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\r\n        if (strict && lookahead.octal) {\r\n            throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\r\n        }\r\n        expr = delegate.createLiteral(lex());\r\n    }\r\n    else if (type === Token.Keyword) {\r\n        if (matchKeyword('function')) {\r\n            return parseFunctionExpression();\r\n        }\r\n        if (matchKeyword('this')) {\r\n            lex();\r\n            expr = delegate.createThisExpression();\r\n        }\r\n        else {\r\n            throwUnexpected(lex());\r\n        }\r\n    }\r\n    else if (type === Token.BooleanLiteral) {\r\n        token = lex();\r\n        token.value = (token.value === 'true');\r\n        expr = delegate.createLiteral(token);\r\n    }\r\n    else if (type === Token.NullLiteral) {\r\n        token = lex();\r\n        token.value = null;\r\n        expr = delegate.createLiteral(token);\r\n    }\r\n    else if (match('/') || match('/=')) {\r\n        if (typeof extra.tokens !== 'undefined') {\r\n            expr = delegate.createLiteral(collectRegex());\r\n        }\r\n        else {\r\n            expr = delegate.createLiteral(scanRegExp());\r\n        }\r\n        peek();\r\n    }\r\n    else {\r\n        throwUnexpected(lex());\r\n    }\r\n    return delegate.markEnd(expr, startToken);\r\n}\r\n// 11.2 Left-Hand-Side Expressions\r\nfunction parseArguments() {\r\n    var args = [];\r\n    expect('(');\r\n    if (!match(')')) {\r\n        while (index < length) {\r\n            args.push(parseAssignmentExpression());\r\n            if (match(')')) {\r\n                break;\r\n            }\r\n            expect(',');\r\n        }\r\n    }\r\n    expect(')');\r\n    return args;\r\n}\r\nfunction parseNonComputedProperty() {\r\n    var token, startToken;\r\n    startToken = lookahead;\r\n    token = lex();\r\n    if (!isIdentifierName(token)) {\r\n        throwUnexpected(token);\r\n    }\r\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\r\n}\r\nfunction parseNonComputedMember() {\r\n    expect('.');\r\n    return parseNonComputedProperty();\r\n}\r\nfunction parseComputedMember() {\r\n    var expr;\r\n    expect('[');\r\n    expr = parseExpression();\r\n    expect(']');\r\n    return expr;\r\n}\r\nfunction parseNewExpression() {\r\n    var callee, args, startToken;\r\n    startToken = lookahead;\r\n    expectKeyword('new');\r\n    callee = parseLeftHandSideExpression();\r\n    args = match('(') ? parseArguments() : [];\r\n    return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);\r\n}\r\nfunction parseLeftHandSideExpressionAllowCall() {\r\n    var previousAllowIn, expr, args, property, startToken;\r\n    startToken = lookahead;\r\n    previousAllowIn = state.allowIn;\r\n    state.allowIn = true;\r\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\r\n    state.allowIn = previousAllowIn;\r\n    for (;;) {\r\n        if (match('.')) {\r\n            property = parseNonComputedMember();\r\n            expr = delegate.createMemberExpression('.', expr, property);\r\n        }\r\n        else if (match('(')) {\r\n            args = parseArguments();\r\n            expr = delegate.createCallExpression(expr, args);\r\n        }\r\n        else if (match('[')) {\r\n            property = parseComputedMember();\r\n            expr = delegate.createMemberExpression('[', expr, property);\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n        delegate.markEnd(expr, startToken);\r\n    }\r\n    return expr;\r\n}\r\nfunction parseLeftHandSideExpression() {\r\n    var previousAllowIn, expr, property, startToken;\r\n    startToken = lookahead;\r\n    previousAllowIn = state.allowIn;\r\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\r\n    state.allowIn = previousAllowIn;\r\n    while (match('.') || match('[')) {\r\n        if (match('[')) {\r\n            property = parseComputedMember();\r\n            expr = delegate.createMemberExpression('[', expr, property);\r\n        }\r\n        else {\r\n            property = parseNonComputedMember();\r\n            expr = delegate.createMemberExpression('.', expr, property);\r\n        }\r\n        delegate.markEnd(expr, startToken);\r\n    }\r\n    return expr;\r\n}\r\n// 11.3 Postfix Expressions\r\nfunction parsePostfixExpression() {\r\n    var expr, token, startToken = lookahead;\r\n    expr = parseLeftHandSideExpressionAllowCall();\r\n    if (lookahead.type === Token.Punctuator) {\r\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\r\n            // 11.3.1, 11.3.2\r\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\r\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\r\n            }\r\n            if (!isLeftHandSide(expr)) {\r\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\r\n            }\r\n            token = lex();\r\n            expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);\r\n        }\r\n    }\r\n    return expr;\r\n}\r\n// 11.4 Unary Operators\r\nfunction parseUnaryExpression() {\r\n    var token, expr, startToken;\r\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\r\n        expr = parsePostfixExpression();\r\n    }\r\n    else if (match('++') || match('--')) {\r\n        startToken = lookahead;\r\n        token = lex();\r\n        expr = parseUnaryExpression();\r\n        // 11.4.4, 11.4.5\r\n        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\r\n            throwErrorTolerant({}, Messages.StrictLHSPrefix);\r\n        }\r\n        if (!isLeftHandSide(expr)) {\r\n            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\r\n        }\r\n        expr = delegate.createUnaryExpression(token.value, expr);\r\n        expr = delegate.markEnd(expr, startToken);\r\n    }\r\n    else if (match('+') || match('-') || match('~') || match('!')) {\r\n        startToken = lookahead;\r\n        token = lex();\r\n        expr = parseUnaryExpression();\r\n        expr = delegate.createUnaryExpression(token.value, expr);\r\n        expr = delegate.markEnd(expr, startToken);\r\n    }\r\n    else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\r\n        startToken = lookahead;\r\n        token = lex();\r\n        expr = parseUnaryExpression();\r\n        expr = delegate.createUnaryExpression(token.value, expr);\r\n        expr = delegate.markEnd(expr, startToken);\r\n        if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\r\n            throwErrorTolerant({}, Messages.StrictDelete);\r\n        }\r\n    }\r\n    else {\r\n        expr = parsePostfixExpression();\r\n    }\r\n    return expr;\r\n}\r\nfunction binaryPrecedence(token, allowIn) {\r\n    var prec = 0;\r\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\r\n        return 0;\r\n    }\r\n    switch (token.value) {\r\n        case '||':\r\n            prec = 1;\r\n            break;\r\n        case '&&':\r\n            prec = 2;\r\n            break;\r\n        case '|':\r\n            prec = 3;\r\n            break;\r\n        case '^':\r\n            prec = 4;\r\n            break;\r\n        case '&':\r\n            prec = 5;\r\n            break;\r\n        case '==':\r\n        case '!=':\r\n        case '===':\r\n        case '!==':\r\n            prec = 6;\r\n            break;\r\n        case '<':\r\n        case '>':\r\n        case '<=':\r\n        case '>=':\r\n        case 'instanceof':\r\n            prec = 7;\r\n            break;\r\n        case 'in':\r\n            prec = allowIn ? 7 : 0;\r\n            break;\r\n        case '<<':\r\n        case '>>':\r\n        case '>>>':\r\n            prec = 8;\r\n            break;\r\n        case '+':\r\n        case '-':\r\n            prec = 9;\r\n            break;\r\n        case '*':\r\n        case '/':\r\n        case '%':\r\n            prec = 11;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    return prec;\r\n}\r\n// 11.5 Multiplicative Operators\r\n// 11.6 Additive Operators\r\n// 11.7 Bitwise Shift Operators\r\n// 11.8 Relational Operators\r\n// 11.9 Equality Operators\r\n// 11.10 Binary Bitwise Operators\r\n// 11.11 Binary Logical Operators\r\nfunction parseBinaryExpression() {\r\n    var marker, markers, expr, token, prec, stack, right, operator, left, i;\r\n    marker = lookahead;\r\n    left = parseUnaryExpression();\r\n    token = lookahead;\r\n    prec = binaryPrecedence(token, state.allowIn);\r\n    if (prec === 0) {\r\n        return left;\r\n    }\r\n    token.prec = prec;\r\n    lex();\r\n    markers = [marker, lookahead];\r\n    right = parseUnaryExpression();\r\n    stack = [left, token, right];\r\n    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\r\n        // Reduce: make a binary expression from the three topmost entries.\r\n        while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\r\n            right = stack.pop();\r\n            operator = stack.pop().value;\r\n            left = stack.pop();\r\n            expr = delegate.createBinaryExpression(operator, left, right);\r\n            markers.pop();\r\n            marker = markers[markers.length - 1];\r\n            delegate.markEnd(expr, marker);\r\n            stack.push(expr);\r\n        }\r\n        // Shift.\r\n        token = lex();\r\n        token.prec = prec;\r\n        stack.push(token);\r\n        markers.push(lookahead);\r\n        expr = parseUnaryExpression();\r\n        stack.push(expr);\r\n    }\r\n    // Final reduce to clean-up the stack.\r\n    i = stack.length - 1;\r\n    expr = stack[i];\r\n    markers.pop();\r\n    while (i > 1) {\r\n        expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\r\n        i -= 2;\r\n        marker = markers.pop();\r\n        delegate.markEnd(expr, marker);\r\n    }\r\n    return expr;\r\n}\r\n// 11.12 Conditional Operator\r\nfunction parseConditionalExpression() {\r\n    var expr, previousAllowIn, consequent, alternate, startToken;\r\n    startToken = lookahead;\r\n    expr = parseBinaryExpression();\r\n    if (match('?')) {\r\n        lex();\r\n        previousAllowIn = state.allowIn;\r\n        state.allowIn = true;\r\n        consequent = parseAssignmentExpression();\r\n        state.allowIn = previousAllowIn;\r\n        expect(':');\r\n        alternate = parseAssignmentExpression();\r\n        expr = delegate.createConditionalExpression(expr, consequent, alternate);\r\n        delegate.markEnd(expr, startToken);\r\n    }\r\n    return expr;\r\n}\r\n// 11.13 Assignment Operators\r\nfunction parseAssignmentExpression() {\r\n    var token, left, right, node, startToken;\r\n    token = lookahead;\r\n    startToken = lookahead;\r\n    node = left = parseConditionalExpression();\r\n    if (matchAssign()) {\r\n        // LeftHandSideExpression\r\n        if (!isLeftHandSide(left)) {\r\n            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\r\n        }\r\n        // 11.13.1\r\n        if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\r\n            throwErrorTolerant(token, Messages.StrictLHSAssignment);\r\n        }\r\n        token = lex();\r\n        right = parseAssignmentExpression();\r\n        node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);\r\n    }\r\n    return node;\r\n}\r\n// 11.14 Comma Operator\r\nfunction parseExpression() {\r\n    var expr, startToken = lookahead;\r\n    expr = parseAssignmentExpression();\r\n    if (match(',')) {\r\n        expr = delegate.createSequenceExpression([expr]);\r\n        while (index < length) {\r\n            if (!match(',')) {\r\n                break;\r\n            }\r\n            lex();\r\n            expr.expressions.push(parseAssignmentExpression());\r\n        }\r\n        delegate.markEnd(expr, startToken);\r\n    }\r\n    return expr;\r\n}\r\n// 12.1 Block\r\nfunction parseStatementList() {\r\n    var list = [], statement;\r\n    while (index < length) {\r\n        if (match('}')) {\r\n            break;\r\n        }\r\n        statement = parseSourceElement();\r\n        if (typeof statement === 'undefined') {\r\n            break;\r\n        }\r\n        list.push(statement);\r\n    }\r\n    return list;\r\n}\r\nfunction parseBlock() {\r\n    var block, startToken;\r\n    startToken = lookahead;\r\n    expect('{');\r\n    block = parseStatementList();\r\n    expect('}');\r\n    return delegate.markEnd(delegate.createBlockStatement(block), startToken);\r\n}\r\n// 12.2 Variable Statement\r\nfunction parseVariableIdentifier() {\r\n    var token, startToken;\r\n    startToken = lookahead;\r\n    token = lex();\r\n    if (token.type !== Token.Identifier) {\r\n        throwUnexpected(token);\r\n    }\r\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\r\n}\r\nfunction parseVariableDeclaration(kind) {\r\n    var init = null, id, startToken;\r\n    startToken = lookahead;\r\n    id = parseVariableIdentifier();\r\n    // 12.2.1\r\n    if (strict && isRestrictedWord(id.name)) {\r\n        throwErrorTolerant({}, Messages.StrictVarName);\r\n    }\r\n    if (kind === 'const') {\r\n        expect('=');\r\n        init = parseAssignmentExpression();\r\n    }\r\n    else if (match('=')) {\r\n        lex();\r\n        init = parseAssignmentExpression();\r\n    }\r\n    return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);\r\n}\r\nfunction parseVariableDeclarationList(kind) {\r\n    var list = [];\r\n    do {\r\n        list.push(parseVariableDeclaration(kind));\r\n        if (!match(',')) {\r\n            break;\r\n        }\r\n        lex();\r\n    } while (index < length);\r\n    return list;\r\n}\r\nfunction parseVariableStatement() {\r\n    var declarations;\r\n    expectKeyword('var');\r\n    declarations = parseVariableDeclarationList();\r\n    consumeSemicolon();\r\n    return delegate.createVariableDeclaration(declarations, 'var');\r\n}\r\n// kind may be `const` or `let`\r\n// Both are experimental and not in the specification yet.\r\n// see http://wiki.ecmascript.org/doku.php?id=harmony:const\r\n// and http://wiki.ecmascript.org/doku.php?id=harmony:let\r\nfunction parseConstLetDeclaration(kind) {\r\n    var declarations, startToken;\r\n    startToken = lookahead;\r\n    expectKeyword(kind);\r\n    declarations = parseVariableDeclarationList(kind);\r\n    consumeSemicolon();\r\n    return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);\r\n}\r\n// 12.3 Empty Statement\r\nfunction parseEmptyStatement() {\r\n    expect(';');\r\n    return delegate.createEmptyStatement();\r\n}\r\n// 12.4 Expression Statement\r\nfunction parseExpressionStatement() {\r\n    var expr = parseExpression();\r\n    consumeSemicolon();\r\n    return delegate.createExpressionStatement(expr);\r\n}\r\n// 12.5 If statement\r\nfunction parseIfStatement() {\r\n    var test, consequent, alternate;\r\n    expectKeyword('if');\r\n    expect('(');\r\n    test = parseExpression();\r\n    expect(')');\r\n    consequent = parseStatement();\r\n    if (matchKeyword('else')) {\r\n        lex();\r\n        alternate = parseStatement();\r\n    }\r\n    else {\r\n        alternate = null;\r\n    }\r\n    return delegate.createIfStatement(test, consequent, alternate);\r\n}\r\n// 12.6 Iteration Statements\r\nfunction parseDoWhileStatement() {\r\n    var body, test, oldInIteration;\r\n    expectKeyword('do');\r\n    oldInIteration = state.inIteration;\r\n    state.inIteration = true;\r\n    body = parseStatement();\r\n    state.inIteration = oldInIteration;\r\n    expectKeyword('while');\r\n    expect('(');\r\n    test = parseExpression();\r\n    expect(')');\r\n    if (match(';')) {\r\n        lex();\r\n    }\r\n    return delegate.createDoWhileStatement(body, test);\r\n}\r\nfunction parseWhileStatement() {\r\n    var test, body, oldInIteration;\r\n    expectKeyword('while');\r\n    expect('(');\r\n    test = parseExpression();\r\n    expect(')');\r\n    oldInIteration = state.inIteration;\r\n    state.inIteration = true;\r\n    body = parseStatement();\r\n    state.inIteration = oldInIteration;\r\n    return delegate.createWhileStatement(test, body);\r\n}\r\nfunction parseForVariableDeclaration() {\r\n    var token, declarations, startToken;\r\n    startToken = lookahead;\r\n    token = lex();\r\n    declarations = parseVariableDeclarationList();\r\n    return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);\r\n}\r\nfunction parseForStatement() {\r\n    var init, test, update, left, right, body, oldInIteration;\r\n    init = test = update = null;\r\n    expectKeyword('for');\r\n    expect('(');\r\n    if (match(';')) {\r\n        lex();\r\n    }\r\n    else {\r\n        if (matchKeyword('var') || matchKeyword('let')) {\r\n            state.allowIn = false;\r\n            init = parseForVariableDeclaration();\r\n            state.allowIn = true;\r\n            if (init.declarations.length === 1 && matchKeyword('in')) {\r\n                lex();\r\n                left = init;\r\n                right = parseExpression();\r\n                init = null;\r\n            }\r\n        }\r\n        else {\r\n            state.allowIn = false;\r\n            init = parseExpression();\r\n            state.allowIn = true;\r\n            if (matchKeyword('in')) {\r\n                // LeftHandSideExpression\r\n                if (!isLeftHandSide(init)) {\r\n                    throwErrorTolerant({}, Messages.InvalidLHSInForIn);\r\n                }\r\n                lex();\r\n                left = init;\r\n                right = parseExpression();\r\n                init = null;\r\n            }\r\n        }\r\n        if (typeof left === 'undefined') {\r\n            expect(';');\r\n        }\r\n    }\r\n    if (typeof left === 'undefined') {\r\n        if (!match(';')) {\r\n            test = parseExpression();\r\n        }\r\n        expect(';');\r\n        if (!match(')')) {\r\n            update = parseExpression();\r\n        }\r\n    }\r\n    expect(')');\r\n    oldInIteration = state.inIteration;\r\n    state.inIteration = true;\r\n    body = parseStatement();\r\n    state.inIteration = oldInIteration;\r\n    return (typeof left === 'undefined') ?\r\n        delegate.createForStatement(init, test, update, body) :\r\n        delegate.createForInStatement(left, right, body);\r\n}\r\n// 12.7 The continue statement\r\nfunction parseContinueStatement() {\r\n    var label = null, key;\r\n    expectKeyword('continue');\r\n    // Optimize the most common form: 'continue;'.\r\n    if (source.charCodeAt(index) === 0x3B) {\r\n        lex();\r\n        if (!state.inIteration) {\r\n            throwError({}, Messages.IllegalContinue);\r\n        }\r\n        return delegate.createContinueStatement(null);\r\n    }\r\n    if (peekLineTerminator()) {\r\n        if (!state.inIteration) {\r\n            throwError({}, Messages.IllegalContinue);\r\n        }\r\n        return delegate.createContinueStatement(null);\r\n    }\r\n    if (lookahead.type === Token.Identifier) {\r\n        label = parseVariableIdentifier();\r\n        key = '$' + label.name;\r\n        if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\r\n            throwError({}, Messages.UnknownLabel, label.name);\r\n        }\r\n    }\r\n    consumeSemicolon();\r\n    if (label === null && !state.inIteration) {\r\n        throwError({}, Messages.IllegalContinue);\r\n    }\r\n    return delegate.createContinueStatement(label);\r\n}\r\n// 12.8 The break statement\r\nfunction parseBreakStatement() {\r\n    var label = null, key;\r\n    expectKeyword('break');\r\n    // Catch the very common case first: immediately a semicolon (U+003B).\r\n    if (source.charCodeAt(index) === 0x3B) {\r\n        lex();\r\n        if (!(state.inIteration || state.inSwitch)) {\r\n            throwError({}, Messages.IllegalBreak);\r\n        }\r\n        return delegate.createBreakStatement(null);\r\n    }\r\n    if (peekLineTerminator()) {\r\n        if (!(state.inIteration || state.inSwitch)) {\r\n            throwError({}, Messages.IllegalBreak);\r\n        }\r\n        return delegate.createBreakStatement(null);\r\n    }\r\n    if (lookahead.type === Token.Identifier) {\r\n        label = parseVariableIdentifier();\r\n        key = '$' + label.name;\r\n        if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\r\n            throwError({}, Messages.UnknownLabel, label.name);\r\n        }\r\n    }\r\n    consumeSemicolon();\r\n    if (label === null && !(state.inIteration || state.inSwitch)) {\r\n        throwError({}, Messages.IllegalBreak);\r\n    }\r\n    return delegate.createBreakStatement(label);\r\n}\r\n// 12.9 The return statement\r\nfunction parseReturnStatement() {\r\n    var argument = null;\r\n    expectKeyword('return');\r\n    if (!state.inFunctionBody) {\r\n        throwErrorTolerant({}, Messages.IllegalReturn);\r\n    }\r\n    // 'return' followed by a space and an identifier is very common.\r\n    if (source.charCodeAt(index) === 0x20) {\r\n        if (isIdentifierStart(source.charCodeAt(index + 1))) {\r\n            argument = parseExpression();\r\n            consumeSemicolon();\r\n            return delegate.createReturnStatement(argument);\r\n        }\r\n    }\r\n    if (peekLineTerminator()) {\r\n        return delegate.createReturnStatement(null);\r\n    }\r\n    if (!match(';')) {\r\n        if (!match('}') && lookahead.type !== Token.EOF) {\r\n            argument = parseExpression();\r\n        }\r\n    }\r\n    consumeSemicolon();\r\n    return delegate.createReturnStatement(argument);\r\n}\r\n// 12.10 The with statement\r\nfunction parseWithStatement() {\r\n    var object, body;\r\n    if (strict) {\r\n        // TODO(ikarienator): Should we update the test cases instead?\r\n        skipComment();\r\n        throwErrorTolerant({}, Messages.StrictModeWith);\r\n    }\r\n    expectKeyword('with');\r\n    expect('(');\r\n    object = parseExpression();\r\n    expect(')');\r\n    body = parseStatement();\r\n    return delegate.createWithStatement(object, body);\r\n}\r\n// 12.10 The swith statement\r\nfunction parseSwitchCase() {\r\n    var test, consequent = [], statement, startToken;\r\n    startToken = lookahead;\r\n    if (matchKeyword('default')) {\r\n        lex();\r\n        test = null;\r\n    }\r\n    else {\r\n        expectKeyword('case');\r\n        test = parseExpression();\r\n    }\r\n    expect(':');\r\n    while (index < length) {\r\n        if (match('}') || matchKeyword('default') || matchKeyword('case')) {\r\n            break;\r\n        }\r\n        statement = parseStatement();\r\n        consequent.push(statement);\r\n    }\r\n    return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);\r\n}\r\nfunction parseSwitchStatement() {\r\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\r\n    expectKeyword('switch');\r\n    expect('(');\r\n    discriminant = parseExpression();\r\n    expect(')');\r\n    expect('{');\r\n    cases = [];\r\n    if (match('}')) {\r\n        lex();\r\n        return delegate.createSwitchStatement(discriminant, cases);\r\n    }\r\n    oldInSwitch = state.inSwitch;\r\n    state.inSwitch = true;\r\n    defaultFound = false;\r\n    while (index < length) {\r\n        if (match('}')) {\r\n            break;\r\n        }\r\n        clause = parseSwitchCase();\r\n        if (clause.test === null) {\r\n            if (defaultFound) {\r\n                throwError({}, Messages.MultipleDefaultsInSwitch);\r\n            }\r\n            defaultFound = true;\r\n        }\r\n        cases.push(clause);\r\n    }\r\n    state.inSwitch = oldInSwitch;\r\n    expect('}');\r\n    return delegate.createSwitchStatement(discriminant, cases);\r\n}\r\n// 12.13 The throw statement\r\nfunction parseThrowStatement() {\r\n    var argument;\r\n    expectKeyword('throw');\r\n    if (peekLineTerminator()) {\r\n        throwError({}, Messages.NewlineAfterThrow);\r\n    }\r\n    argument = parseExpression();\r\n    consumeSemicolon();\r\n    return delegate.createThrowStatement(argument);\r\n}\r\n// 12.14 The try statement\r\nfunction parseCatchClause() {\r\n    var param, body, startToken;\r\n    startToken = lookahead;\r\n    expectKeyword('catch');\r\n    expect('(');\r\n    if (match(')')) {\r\n        throwUnexpected(lookahead);\r\n    }\r\n    param = parseVariableIdentifier();\r\n    // 12.14.1\r\n    if (strict && isRestrictedWord(param.name)) {\r\n        throwErrorTolerant({}, Messages.StrictCatchVariable);\r\n    }\r\n    expect(')');\r\n    body = parseBlock();\r\n    return delegate.markEnd(delegate.createCatchClause(param, body), startToken);\r\n}\r\nfunction parseTryStatement() {\r\n    var block, handlers = [], finalizer = null;\r\n    expectKeyword('try');\r\n    block = parseBlock();\r\n    if (matchKeyword('catch')) {\r\n        handlers.push(parseCatchClause());\r\n    }\r\n    if (matchKeyword('finally')) {\r\n        lex();\r\n        finalizer = parseBlock();\r\n    }\r\n    if (handlers.length === 0 && !finalizer) {\r\n        throwError({}, Messages.NoCatchOrFinally);\r\n    }\r\n    return delegate.createTryStatement(block, [], handlers, finalizer);\r\n}\r\n// 12.15 The debugger statement\r\nfunction parseDebuggerStatement() {\r\n    expectKeyword('debugger');\r\n    consumeSemicolon();\r\n    return delegate.createDebuggerStatement();\r\n}\r\n// 12 Statements\r\nfunction parseStatement() {\r\n    var type = lookahead.type, expr, labeledBody, key, startToken;\r\n    if (type === Token.EOF) {\r\n        throwUnexpected(lookahead);\r\n    }\r\n    if (type === Token.Punctuator && lookahead.value === '{') {\r\n        return parseBlock();\r\n    }\r\n    startToken = lookahead;\r\n    if (type === Token.Punctuator) {\r\n        switch (lookahead.value) {\r\n            case ';':\r\n                return delegate.markEnd(parseEmptyStatement(), startToken);\r\n            case '(':\r\n                return delegate.markEnd(parseExpressionStatement(), startToken);\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    if (type === Token.Keyword) {\r\n        switch (lookahead.value) {\r\n            case 'break':\r\n                return delegate.markEnd(parseBreakStatement(), startToken);\r\n            case 'continue':\r\n                return delegate.markEnd(parseContinueStatement(), startToken);\r\n            case 'debugger':\r\n                return delegate.markEnd(parseDebuggerStatement(), startToken);\r\n            case 'do':\r\n                return delegate.markEnd(parseDoWhileStatement(), startToken);\r\n            case 'for':\r\n                return delegate.markEnd(parseForStatement(), startToken);\r\n            case 'function':\r\n                return delegate.markEnd(parseFunctionDeclaration(), startToken);\r\n            case 'if':\r\n                return delegate.markEnd(parseIfStatement(), startToken);\r\n            case 'return':\r\n                return delegate.markEnd(parseReturnStatement(), startToken);\r\n            case 'switch':\r\n                return delegate.markEnd(parseSwitchStatement(), startToken);\r\n            case 'throw':\r\n                return delegate.markEnd(parseThrowStatement(), startToken);\r\n            case 'try':\r\n                return delegate.markEnd(parseTryStatement(), startToken);\r\n            case 'var':\r\n                return delegate.markEnd(parseVariableStatement(), startToken);\r\n            case 'while':\r\n                return delegate.markEnd(parseWhileStatement(), startToken);\r\n            case 'with':\r\n                return delegate.markEnd(parseWithStatement(), startToken);\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    expr = parseExpression();\r\n    // 12.12 Labelled Statements\r\n    if ((expr.type === Syntax.Identifier) && match(':')) {\r\n        lex();\r\n        key = '$' + expr.name;\r\n        if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\r\n            throwError({}, Messages.Redeclaration, 'Label', expr.name);\r\n        }\r\n        state.labelSet[key] = true;\r\n        labeledBody = parseStatement();\r\n        delete state.labelSet[key];\r\n        return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);\r\n    }\r\n    consumeSemicolon();\r\n    return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);\r\n}\r\n// 13 Function Definition\r\nfunction parseFunctionSourceElements() {\r\n    var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;\r\n    startToken = lookahead;\r\n    expect('{');\r\n    while (index < length) {\r\n        if (lookahead.type !== Token.StringLiteral) {\r\n            break;\r\n        }\r\n        token = lookahead;\r\n        sourceElement = parseSourceElement();\r\n        sourceElements.push(sourceElement);\r\n        if (sourceElement.expression.type !== Syntax.Literal) {\r\n            // this is not directive\r\n            break;\r\n        }\r\n        directive = source.slice(token.start + 1, token.end - 1);\r\n        if (directive === 'use strict') {\r\n            strict = true;\r\n            if (firstRestricted) {\r\n                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\r\n            }\r\n        }\r\n        else {\r\n            if (!firstRestricted && token.octal) {\r\n                firstRestricted = token;\r\n            }\r\n        }\r\n    }\r\n    oldLabelSet = state.labelSet;\r\n    oldInIteration = state.inIteration;\r\n    oldInSwitch = state.inSwitch;\r\n    oldInFunctionBody = state.inFunctionBody;\r\n    state.labelSet = {};\r\n    state.inIteration = false;\r\n    state.inSwitch = false;\r\n    state.inFunctionBody = true;\r\n    while (index < length) {\r\n        if (match('}')) {\r\n            break;\r\n        }\r\n        sourceElement = parseSourceElement();\r\n        if (typeof sourceElement === 'undefined') {\r\n            break;\r\n        }\r\n        sourceElements.push(sourceElement);\r\n    }\r\n    expect('}');\r\n    state.labelSet = oldLabelSet;\r\n    state.inIteration = oldInIteration;\r\n    state.inSwitch = oldInSwitch;\r\n    state.inFunctionBody = oldInFunctionBody;\r\n    return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);\r\n}\r\nfunction parseParams(firstRestricted) {\r\n    var param, params = [], token, stricted, paramSet, key, message;\r\n    expect('(');\r\n    if (!match(')')) {\r\n        paramSet = {};\r\n        while (index < length) {\r\n            token = lookahead;\r\n            param = parseVariableIdentifier();\r\n            key = '$' + token.value;\r\n            if (strict) {\r\n                if (isRestrictedWord(token.value)) {\r\n                    stricted = token;\r\n                    message = Messages.StrictParamName;\r\n                }\r\n                if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\r\n                    stricted = token;\r\n                    message = Messages.StrictParamDupe;\r\n                }\r\n            }\r\n            else if (!firstRestricted) {\r\n                if (isRestrictedWord(token.value)) {\r\n                    firstRestricted = token;\r\n                    message = Messages.StrictParamName;\r\n                }\r\n                else if (isStrictModeReservedWord(token.value)) {\r\n                    firstRestricted = token;\r\n                    message = Messages.StrictReservedWord;\r\n                }\r\n                else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\r\n                    firstRestricted = token;\r\n                    message = Messages.StrictParamDupe;\r\n                }\r\n            }\r\n            params.push(param);\r\n            paramSet[key] = true;\r\n            if (match(')')) {\r\n                break;\r\n            }\r\n            expect(',');\r\n        }\r\n    }\r\n    expect(')');\r\n    return {\r\n        params: params,\r\n        stricted: stricted,\r\n        firstRestricted: firstRestricted,\r\n        message: message\r\n    };\r\n}\r\nfunction parseFunctionDeclaration() {\r\n    var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;\r\n    startToken = lookahead;\r\n    expectKeyword('function');\r\n    token = lookahead;\r\n    id = parseVariableIdentifier();\r\n    if (strict) {\r\n        if (isRestrictedWord(token.value)) {\r\n            throwErrorTolerant(token, Messages.StrictFunctionName);\r\n        }\r\n    }\r\n    else {\r\n        if (isRestrictedWord(token.value)) {\r\n            firstRestricted = token;\r\n            message = Messages.StrictFunctionName;\r\n        }\r\n        else if (isStrictModeReservedWord(token.value)) {\r\n            firstRestricted = token;\r\n            message = Messages.StrictReservedWord;\r\n        }\r\n    }\r\n    tmp = parseParams(firstRestricted);\r\n    params = tmp.params;\r\n    stricted = tmp.stricted;\r\n    firstRestricted = tmp.firstRestricted;\r\n    if (tmp.message) {\r\n        message = tmp.message;\r\n    }\r\n    previousStrict = strict;\r\n    body = parseFunctionSourceElements();\r\n    if (strict && firstRestricted) {\r\n        throwError(firstRestricted, message);\r\n    }\r\n    if (strict && stricted) {\r\n        throwErrorTolerant(stricted, message);\r\n    }\r\n    strict = previousStrict;\r\n    return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);\r\n}\r\nfunction parseFunctionExpression() {\r\n    var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;\r\n    startToken = lookahead;\r\n    expectKeyword('function');\r\n    if (!match('(')) {\r\n        token = lookahead;\r\n        id = parseVariableIdentifier();\r\n        if (strict) {\r\n            if (isRestrictedWord(token.value)) {\r\n                throwErrorTolerant(token, Messages.StrictFunctionName);\r\n            }\r\n        }\r\n        else {\r\n            if (isRestrictedWord(token.value)) {\r\n                firstRestricted = token;\r\n                message = Messages.StrictFunctionName;\r\n            }\r\n            else if (isStrictModeReservedWord(token.value)) {\r\n                firstRestricted = token;\r\n                message = Messages.StrictReservedWord;\r\n            }\r\n        }\r\n    }\r\n    tmp = parseParams(firstRestricted);\r\n    params = tmp.params;\r\n    stricted = tmp.stricted;\r\n    firstRestricted = tmp.firstRestricted;\r\n    if (tmp.message) {\r\n        message = tmp.message;\r\n    }\r\n    previousStrict = strict;\r\n    body = parseFunctionSourceElements();\r\n    if (strict && firstRestricted) {\r\n        throwError(firstRestricted, message);\r\n    }\r\n    if (strict && stricted) {\r\n        throwErrorTolerant(stricted, message);\r\n    }\r\n    strict = previousStrict;\r\n    return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);\r\n}\r\n// 14 Program\r\nfunction parseSourceElement() {\r\n    if (lookahead.type === Token.Keyword) {\r\n        switch (lookahead.value) {\r\n            case 'const':\r\n            case 'let':\r\n                return parseConstLetDeclaration(lookahead.value);\r\n            case 'function':\r\n                return parseFunctionDeclaration();\r\n            default:\r\n                return parseStatement();\r\n        }\r\n    }\r\n    if (lookahead.type !== Token.EOF) {\r\n        return parseStatement();\r\n    }\r\n}\r\nfunction parseSourceElements() {\r\n    var sourceElement, sourceElements = [], token, directive, firstRestricted;\r\n    while (index < length) {\r\n        token = lookahead;\r\n        if (token.type !== Token.StringLiteral) {\r\n            break;\r\n        }\r\n        sourceElement = parseSourceElement();\r\n        sourceElements.push(sourceElement);\r\n        if (sourceElement.expression.type !== Syntax.Literal) {\r\n            // this is not directive\r\n            break;\r\n        }\r\n        directive = source.slice(token.start + 1, token.end - 1);\r\n        if (directive === 'use strict') {\r\n            strict = true;\r\n            if (firstRestricted) {\r\n                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\r\n            }\r\n        }\r\n        else {\r\n            if (!firstRestricted && token.octal) {\r\n                firstRestricted = token;\r\n            }\r\n        }\r\n    }\r\n    while (index < length) {\r\n        sourceElement = parseSourceElement();\r\n        /* istanbul ignore if */\r\n        if (typeof sourceElement === 'undefined') {\r\n            break;\r\n        }\r\n        sourceElements.push(sourceElement);\r\n    }\r\n    return sourceElements;\r\n}\r\nfunction parseProgram() {\r\n    var body, startToken;\r\n    skipComment();\r\n    peek();\r\n    startToken = lookahead;\r\n    strict = false;\r\n    body = parseSourceElements();\r\n    return delegate.markEnd(delegate.createProgram(body), startToken);\r\n}\r\nfunction filterTokenLocation() {\r\n    var i, entry, token, tokens = [];\r\n    for (i = 0; i < extra.tokens.length; ++i) {\r\n        entry = extra.tokens[i];\r\n        token = {\r\n            type: entry.type,\r\n            value: entry.value\r\n        };\r\n        if (extra.range) {\r\n            token.range = entry.range;\r\n        }\r\n        if (extra.loc) {\r\n            token.loc = entry.loc;\r\n        }\r\n        tokens.push(token);\r\n    }\r\n    extra.tokens = tokens;\r\n}\r\nfunction tokenize(code, options) {\r\n    var toString, token, tokens;\r\n    toString = String;\r\n    if (typeof code !== 'string' && !(code instanceof String)) {\r\n        code = toString(code);\r\n    }\r\n    delegate = SyntaxTreeDelegate;\r\n    source = code;\r\n    index = 0;\r\n    lineNumber = (source.length > 0) ? 1 : 0;\r\n    lineStart = 0;\r\n    length = source.length;\r\n    lookahead = null;\r\n    state = {\r\n        allowIn: true,\r\n        labelSet: {},\r\n        inFunctionBody: false,\r\n        inIteration: false,\r\n        inSwitch: false,\r\n        lastCommentStart: -1\r\n    };\r\n    extra = {};\r\n    // Options matching.\r\n    options = options || {};\r\n    // Of course we collect tokens here.\r\n    options.tokens = true;\r\n    extra.tokens = [];\r\n    extra.tokenize = true;\r\n    // The following two fields are necessary to compute the Regex tokens.\r\n    extra.openParenToken = -1;\r\n    extra.openCurlyToken = -1;\r\n    extra.range = (typeof options.range === 'boolean') && options.range;\r\n    extra.loc = (typeof options.loc === 'boolean') && options.loc;\r\n    if (typeof options.comment === 'boolean' && options.comment) {\r\n        extra.comments = [];\r\n    }\r\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\r\n        extra.errors = [];\r\n    }\r\n    try {\r\n        peek();\r\n        if (lookahead.type === Token.EOF) {\r\n            return extra.tokens;\r\n        }\r\n        token = lex();\r\n        while (lookahead.type !== Token.EOF) {\r\n            try {\r\n                token = lex();\r\n            }\r\n            catch (lexError) {\r\n                token = lookahead;\r\n                if (extra.errors) {\r\n                    extra.errors.push(lexError);\r\n                    // We have to break on the first error\r\n                    // to avoid infinite loops.\r\n                    break;\r\n                }\r\n                else {\r\n                    throw lexError;\r\n                }\r\n            }\r\n        }\r\n        filterTokenLocation();\r\n        tokens = extra.tokens;\r\n        if (typeof extra.comments !== 'undefined') {\r\n            tokens.comments = extra.comments;\r\n        }\r\n        if (typeof extra.errors !== 'undefined') {\r\n            tokens.errors = extra.errors;\r\n        }\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n    finally {\r\n        extra = {};\r\n    }\r\n    return tokens;\r\n}\r\nfunction parse(code, options) {\r\n    var program, toString;\r\n    toString = String;\r\n    if (typeof code !== 'string' && !(code instanceof String)) {\r\n        code = toString(code);\r\n    }\r\n    delegate = SyntaxTreeDelegate;\r\n    source = code;\r\n    index = 0;\r\n    lineNumber = (source.length > 0) ? 1 : 0;\r\n    lineStart = 0;\r\n    length = source.length;\r\n    lookahead = null;\r\n    state = {\r\n        allowIn: true,\r\n        labelSet: {},\r\n        inFunctionBody: false,\r\n        inIteration: false,\r\n        inSwitch: false,\r\n        lastCommentStart: -1\r\n    };\r\n    extra = {};\r\n    if (typeof options !== 'undefined') {\r\n        extra.range = (typeof options.range === 'boolean') && options.range;\r\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\r\n        extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\r\n        if (extra.loc && options.source !== null && options.source !== undefined) {\r\n            extra.source = toString(options.source);\r\n        }\r\n        if (typeof options.tokens === 'boolean' && options.tokens) {\r\n            extra.tokens = [];\r\n        }\r\n        if (typeof options.comment === 'boolean' && options.comment) {\r\n            extra.comments = [];\r\n        }\r\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\r\n            extra.errors = [];\r\n        }\r\n        if (extra.attachComment) {\r\n            extra.range = true;\r\n            extra.comments = [];\r\n            extra.bottomRightStack = [];\r\n            extra.trailingComments = [];\r\n            extra.leadingComments = [];\r\n        }\r\n    }\r\n    try {\r\n        program = parseProgram();\r\n        if (typeof extra.comments !== 'undefined') {\r\n            program.comments = extra.comments;\r\n        }\r\n        if (typeof extra.tokens !== 'undefined') {\r\n            filterTokenLocation();\r\n            program.tokens = extra.tokens;\r\n        }\r\n        if (typeof extra.errors !== 'undefined') {\r\n            program.errors = extra.errors;\r\n        }\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n    finally {\r\n        extra = {};\r\n    }\r\n    return program;\r\n}\r\n// Sync with *.json manifests.\r\nvar version = '1.2.2';\r\n/* vim: set sw=4 ts=4 et tw=80 : */\r\n//# sourceMappingURL=esprima.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vZXNwcmltYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B3aGlzdGxleC9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AYXN0cm9uYXV0bGFicy9qc29ucGF0aC9kaXN0LmVzbS9lc3ByaW1hLmpzPzlmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XHJcbiAgQ29weXJpZ2h0IChDKSAyMDEzIFRoYWRkZWUgVHlsIDx0aGFkZGVlLnR5bEBnbWFpbC5jb20+XHJcbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XHJcbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxyXG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxyXG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cclxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XHJcbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cclxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XHJcbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxyXG5cclxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxyXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxyXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxyXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcclxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcclxuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcclxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxyXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiovXHJcbi8qanNsaW50IGJpdHdpc2U6dHJ1ZSBwbHVzcGx1czp0cnVlICovXHJcbi8qZ2xvYmFsIGVzcHJpbWE6dHJ1ZSwgZGVmaW5lOnRydWUsIGV4cG9ydHM6dHJ1ZSwgd2luZG93OiB0cnVlLFxyXG50aHJvd0Vycm9yVG9sZXJhbnQ6IHRydWUsXHJcbnRocm93RXJyb3I6IHRydWUsIGdlbmVyYXRlU3RhdGVtZW50OiB0cnVlLCBwZWVrOiB0cnVlLFxyXG5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uOiB0cnVlLCBwYXJzZUJsb2NrOiB0cnVlLCBwYXJzZUV4cHJlc3Npb246IHRydWUsXHJcbnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbjogdHJ1ZSwgcGFyc2VGdW5jdGlvbkV4cHJlc3Npb246IHRydWUsXHJcbnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50czogdHJ1ZSwgcGFyc2VWYXJpYWJsZUlkZW50aWZpZXI6IHRydWUsXHJcbnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbjogdHJ1ZSxcclxucGFyc2VVbmFyeUV4cHJlc3Npb246IHRydWUsXHJcbnBhcnNlU3RhdGVtZW50OiB0cnVlLCBwYXJzZVNvdXJjZUVsZW1lbnQ6IHRydWUgKi9cclxudmFyIFRva2VuLCBUb2tlbk5hbWUsIEZuRXhwclRva2VucywgUHJvcGVydHlLaW5kLCBNZXNzYWdlcywgUmVnZXgsIFN5bnRheFRyZWVEZWxlZ2F0ZSwgc291cmNlLCBzdHJpY3QsIGluZGV4LCBsaW5lTnVtYmVyLCBsaW5lU3RhcnQsIGxlbmd0aCwgZGVsZWdhdGUsIGxvb2thaGVhZCwgc3RhdGUsIGV4dHJhO1xyXG5Ub2tlbiA9IHtcclxuICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxyXG4gICAgRU9GOiAyLFxyXG4gICAgSWRlbnRpZmllcjogMyxcclxuICAgIEtleXdvcmQ6IDQsXHJcbiAgICBOdWxsTGl0ZXJhbDogNSxcclxuICAgIE51bWVyaWNMaXRlcmFsOiA2LFxyXG4gICAgUHVuY3R1YXRvcjogNyxcclxuICAgIFN0cmluZ0xpdGVyYWw6IDgsXHJcbiAgICBSZWd1bGFyRXhwcmVzc2lvbjogOVxyXG59O1xyXG5Ub2tlbk5hbWUgPSB7fTtcclxuVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcclxuVG9rZW5OYW1lW1Rva2VuLkVPRl0gPSAnPGVuZD4nO1xyXG5Ub2tlbk5hbWVbVG9rZW4uSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XHJcblRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcclxuVG9rZW5OYW1lW1Rva2VuLk51bGxMaXRlcmFsXSA9ICdOdWxsJztcclxuVG9rZW5OYW1lW1Rva2VuLk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcclxuVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xyXG5Ub2tlbk5hbWVbVG9rZW4uU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcclxuVG9rZW5OYW1lW1Rva2VuLlJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XHJcbi8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cclxuRm5FeHByVG9rZW5zID0gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxyXG4gICAgJ3JldHVybicsICdjYXNlJywgJ2RlbGV0ZScsICd0aHJvdycsICd2b2lkJyxcclxuICAgIC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzXHJcbiAgICAnPScsICcrPScsICctPScsICcqPScsICcvPScsICclPScsICc8PD0nLCAnPj49JywgJz4+Pj0nLFxyXG4gICAgJyY9JywgJ3w9JywgJ149JywgJywnLFxyXG4gICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xyXG4gICAgJysnLCAnLScsICcqJywgJy8nLCAnJScsICcrKycsICctLScsICc8PCcsICc+PicsICc+Pj4nLCAnJicsXHJcbiAgICAnfCcsICdeJywgJyEnLCAnficsICcmJicsICd8fCcsICc/JywgJzonLCAnPT09JywgJz09JywgJz49JyxcclxuICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J107XHJcbmV4cG9ydCB2YXIgU3ludGF4ID0ge1xyXG4gICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXHJcbiAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxyXG4gICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXHJcbiAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXHJcbiAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcclxuICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxyXG4gICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXHJcbiAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxyXG4gICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXHJcbiAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXHJcbiAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcclxuICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxyXG4gICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxyXG4gICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcclxuICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxyXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxyXG4gICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcclxuICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcclxuICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxyXG4gICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxyXG4gICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxyXG4gICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXHJcbiAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXHJcbiAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXHJcbiAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXHJcbiAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXHJcbiAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcclxuICAgIFJldHVyblN0YXRlbWVudDogJ1JldHVyblN0YXRlbWVudCcsXHJcbiAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxyXG4gICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcclxuICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcclxuICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxyXG4gICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXHJcbiAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxyXG4gICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcclxuICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcclxuICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcclxuICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXHJcbiAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcclxuICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50J1xyXG59O1xyXG5Qcm9wZXJ0eUtpbmQgPSB7XHJcbiAgICBEYXRhOiAxLFxyXG4gICAgR2V0OiAyLFxyXG4gICAgU2V0OiA0XHJcbn07XHJcbi8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXHJcbk1lc3NhZ2VzID0ge1xyXG4gICAgVW5leHBlY3RlZFRva2VuOiAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXHJcbiAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxyXG4gICAgVW5leHBlY3RlZFN0cmluZzogJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcclxuICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcclxuICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXHJcbiAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxyXG4gICAgTmV3bGluZUFmdGVyVGhyb3c6ICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxyXG4gICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcclxuICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxyXG4gICAgSW52YWxpZExIU0luQXNzaWdubWVudDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXHJcbiAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcclxuICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXHJcbiAgICBOb0NhdGNoT3JGaW5hbGx5OiAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXHJcbiAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxyXG4gICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxyXG4gICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxyXG4gICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxyXG4gICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXHJcbiAgICBTdHJpY3RNb2RlV2l0aDogJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxyXG4gICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG4gICAgU3RyaWN0VmFyTmFtZTogJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcbiAgICBTdHJpY3RQYXJhbU5hbWU6ICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcbiAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXHJcbiAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG4gICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXHJcbiAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxyXG4gICAgU3RyaWN0RHVwbGljYXRlUHJvcGVydHk6ICdEdXBsaWNhdGUgZGF0YSBwcm9wZXJ0eSBpbiBvYmplY3QgbGl0ZXJhbCBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcbiAgICBBY2Nlc3NvckRhdGFQcm9wZXJ0eTogJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBkYXRhIGFuZCBhY2Nlc3NvciBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWUnLFxyXG4gICAgQWNjZXNzb3JHZXRTZXQ6ICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgbXVsdGlwbGUgZ2V0L3NldCBhY2Nlc3NvcnMgd2l0aCB0aGUgc2FtZSBuYW1lJyxcclxuICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICdBc3NpZ25tZW50IHRvIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuICAgIFN0cmljdExIU1Bvc3RmaXg6ICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG4gICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG4gICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAnVXNlIG9mIGZ1dHVyZSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJ1xyXG59O1xyXG4vLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxyXG5SZWdleCA9IHtcclxuICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGMFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjk3XFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE4MC1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJyksXHJcbiAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwXFx1MDhBMi1cXHUwOEFDXFx1MDhFNC1cXHUwOEZFXFx1MDkwMC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdGXFx1MDk4MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDEtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzM1xcdTBDMzUtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OFxcdTBDNTlcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgyXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMlxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkYwXFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUNcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUQwMC1cXHUxREU2XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5N1xcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTc5M1xcdUE3QTAtXFx1QTdBQVxcdUE3RjgtXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3QlxcdUFBODAtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMjZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJylcclxufTtcclxuLy8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxyXG4vLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcclxuLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXHJcbi8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XHJcbiAgICByZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU3KTsgLy8gMC4uOVxyXG59XHJcbmZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcclxuICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicuaW5kZXhPZihjaCkgPj0gMDtcclxufVxyXG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcclxuICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XHJcbn1cclxuLy8gNy4yIFdoaXRlIFNwYWNlXHJcbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xyXG4gICAgcmV0dXJuIChjaCA9PT0gMHgyMCkgfHwgKGNoID09PSAweDA5KSB8fCAoY2ggPT09IDB4MEIpIHx8IChjaCA9PT0gMHgwQykgfHwgKGNoID09PSAweEEwKSB8fFxyXG4gICAgICAgIChjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgxODBFLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNoKSA+PSAwKTtcclxufVxyXG4vLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xyXG5mdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XHJcbiAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XHJcbn1cclxuLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXHJcbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XHJcbiAgICByZXR1cm4gKGNoID09IDB4NDApIHx8IC8vIEAgKGZvciBqc29ucGF0aClcclxuICAgICAgICAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcclxuICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAvLyBBLi5aXHJcbiAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgLy8gYS4uelxyXG4gICAgICAgIChjaCA9PT0gMHg1QykgfHwgLy8gXFwgKGJhY2tzbGFzaClcclxuICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcclxufVxyXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XHJcbiAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8IC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXHJcbiAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgLy8gQS4uWlxyXG4gICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8IC8vIGEuLnpcclxuICAgICAgICAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KSB8fCAvLyAwLi45XHJcbiAgICAgICAgKGNoID09PSAweDVDKSB8fCAvLyBcXCAoYmFja3NsYXNoKVxyXG4gICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XHJcbn1cclxuLy8gNy42LjEuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcclxuZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcclxuICAgIHN3aXRjaCAoaWQpIHtcclxuICAgICAgICBjYXNlICdjbGFzcyc6XHJcbiAgICAgICAgY2FzZSAnZW51bSc6XHJcbiAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuICAgICAgICBjYXNlICdleHRlbmRzJzpcclxuICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG4gICAgICAgIGNhc2UgJ3N1cGVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xyXG4gICAgc3dpdGNoIChpZCkge1xyXG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxyXG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XHJcbiAgICAgICAgY2FzZSAncGFja2FnZSc6XHJcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XHJcbiAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcclxuICAgICAgICBjYXNlICdwdWJsaWMnOlxyXG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XHJcbiAgICAgICAgY2FzZSAneWllbGQnOlxyXG4gICAgICAgIGNhc2UgJ2xldCc6XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1Jlc3RyaWN0ZWRXb3JkKGlkKSB7XHJcbiAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XHJcbn1cclxuLy8gNy42LjEuMSBLZXl3b3Jkc1xyXG5mdW5jdGlvbiBpc0tleXdvcmQoaWQpIHtcclxuICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gJ2NvbnN0JyBpcyBzcGVjaWFsaXplZCBhcyBLZXl3b3JkIGluIFY4LlxyXG4gICAgLy8gJ3lpZWxkJyBhbmQgJ2xldCcgYXJlIGZvciBjb21wYXRpYmxpdHkgd2l0aCBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHQuXHJcbiAgICAvLyBTb21lIG90aGVycyBhcmUgZnJvbSBmdXR1cmUgcmVzZXJ2ZWQgd29yZHMuXHJcbiAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XHJcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcclxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XHJcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcclxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xyXG4gICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8vIDcuNCBDb21tZW50c1xyXG5mdW5jdGlvbiBhZGRDb21tZW50KHR5cGUsIHZhbHVlLCBzdGFydCwgZW5kLCBsb2MpIHtcclxuICAgIHZhciBjb21tZW50LCBhdHRhY2hlcjtcclxuICAgIGFzc2VydCh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInLCAnQ29tbWVudCBtdXN0IGhhdmUgdmFsaWQgcG9zaXRpb24nKTtcclxuICAgIC8vIEJlY2F1c2UgdGhlIHdheSB0aGUgYWN0dWFsIHRva2VuIGlzIHNjYW5uZWQsIG9mdGVuIHRoZSBjb21tZW50c1xyXG4gICAgLy8gKGlmIGFueSkgYXJlIHNraXBwZWQgdHdpY2UgZHVyaW5nIHRoZSBsZXhpY2FsIGFuYWx5c2lzLlxyXG4gICAgLy8gVGh1cywgd2UgbmVlZCB0byBza2lwIGFkZGluZyBhIGNvbW1lbnQgaWYgdGhlIGNvbW1lbnQgYXJyYXkgYWxyZWFkeVxyXG4gICAgLy8gaGFuZGxlZCBpdC5cclxuICAgIGlmIChzdGF0ZS5sYXN0Q29tbWVudFN0YXJ0ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc3RhdGUubGFzdENvbW1lbnRTdGFydCA9IHN0YXJ0O1xyXG4gICAgY29tbWVudCA9IHtcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgfTtcclxuICAgIGlmIChleHRyYS5yYW5nZSkge1xyXG4gICAgICAgIGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07XHJcbiAgICB9XHJcbiAgICBpZiAoZXh0cmEubG9jKSB7XHJcbiAgICAgICAgY29tbWVudC5sb2MgPSBsb2M7XHJcbiAgICB9XHJcbiAgICBleHRyYS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xyXG4gICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcclxuICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcclxuICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2tpcFNpbmdsZUxpbmVDb21tZW50KG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xyXG4gICAgc3RhcnQgPSBpbmRleCAtIG9mZnNldDtcclxuICAgIGxvYyA9IHtcclxuICAgICAgICBzdGFydDoge1xyXG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gb2Zmc2V0XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcbiAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xyXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIG9mZnNldCwgaW5kZXggLSAxKTtcclxuICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gMVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXggLSAxLCBsb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAxMCkge1xyXG4gICAgICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICArK2xpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XHJcbiAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIG9mZnNldCwgaW5kZXgpO1xyXG4gICAgICAgIGxvYy5lbmQgPSB7XHJcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2tpcE11bHRpTGluZUNvbW1lbnQoKSB7XHJcbiAgICB2YXIgc3RhcnQsIGxvYywgY2gsIGNvbW1lbnQ7XHJcbiAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcclxuICAgICAgICBzdGFydCA9IGluZGV4IC0gMjtcclxuICAgICAgICBsb2MgPSB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDB4MEEpIHtcclxuICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XHJcbiAgICAgICAgICAgIC8vIEJsb2NrIGNvbW1lbnQgZW5kcyB3aXRoICcqLycuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDJGKSB7XHJcbiAgICAgICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCAtIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0Jsb2NrJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxufVxyXG5mdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcclxuICAgIHZhciBjaCwgc3RhcnQ7XHJcbiAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xyXG4gICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG4gICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBKSB7XHJcbiAgICAgICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICsrbGluZU51bWJlcjtcclxuICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkYpIHsgLy8gVSswMDJGIGlzICcvJ1xyXG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyRikge1xyXG4gICAgICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoMik7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkEpIHsgLy8gVSswMDJBIGlzICcqJ1xyXG4gICAgICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICBza2lwTXVsdGlMaW5lQ29tbWVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHsgLy8gVSswMDJEIGlzICctJ1xyXG4gICAgICAgICAgICAvLyBVKzAwM0UgaXMgJz4nXHJcbiAgICAgICAgICAgIGlmICgoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgyRCkgJiYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMikgPT09IDB4M0UpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XHJcbiAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzQykgeyAvLyBVKzAwM0MgaXMgJzwnXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDQpID09PSAnIS0tJykge1xyXG4gICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYDxgXHJcbiAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgIWBcclxuICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAtYFxyXG4gICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYC1gXHJcbiAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoNCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XHJcbiAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XHJcbiAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xyXG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcclxuICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xyXG4gICAgdmFyIGNoLCBpZDtcclxuICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XHJcbiAgICBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xyXG4gICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG4gICAgaWYgKGNoID09PSAweDVDKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XHJcbiAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlkID0gY2g7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2luZGV4O1xyXG4gICAgICAgIGlkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xyXG4gICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcclxuICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWQgKz0gY2g7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlkO1xyXG59XHJcbmZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XHJcbiAgICB2YXIgc3RhcnQsIGNoO1xyXG4gICAgc3RhcnQgPSBpbmRleCsrO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XHJcbiAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XHJcbiAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXHJcbiAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRFc2NhcGVkSWRlbnRpZmllcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcclxuICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcclxufVxyXG5mdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcclxuICAgIHZhciBzdGFydCwgaWQsIHR5cGU7XHJcbiAgICBzdGFydCA9IGluZGV4O1xyXG4gICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuICAgIGlkID0gKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QykgPyBnZXRFc2NhcGVkSWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpO1xyXG4gICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxyXG4gICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxyXG4gICAgaWYgKGlkLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNLZXl3b3JkKGlkKSkge1xyXG4gICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xyXG4gICAgICAgIHR5cGUgPSBUb2tlbi5OdWxsTGl0ZXJhbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcclxuICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICB2YWx1ZTogaWQsXHJcbiAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcclxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcclxuICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgZW5kOiBpbmRleFxyXG4gICAgfTtcclxufVxyXG4vLyA3LjcgUHVuY3R1YXRvcnNcclxuZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XHJcbiAgICB2YXIgc3RhcnQgPSBpbmRleCwgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSwgY29kZTIsIGNoMSA9IHNvdXJjZVtpbmRleF0sIGNoMiwgY2gzLCBjaDQ7XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuICAgICAgICBjYXNlIDB4MkU6IC8vIC4gZG90XHJcbiAgICAgICAgY2FzZSAweDI4OiAvLyAoIG9wZW4gYnJhY2tldFxyXG4gICAgICAgIGNhc2UgMHgyOTogLy8gKSBjbG9zZSBicmFja2V0XHJcbiAgICAgICAgY2FzZSAweDNCOiAvLyA7IHNlbWljb2xvblxyXG4gICAgICAgIGNhc2UgMHgyQzogLy8gLCBjb21tYVxyXG4gICAgICAgIGNhc2UgMHg3QjogLy8geyBvcGVuIGN1cmx5IGJyYWNlXHJcbiAgICAgICAgY2FzZSAweDdEOiAvLyB9IGNsb3NlIGN1cmx5IGJyYWNlXHJcbiAgICAgICAgY2FzZSAweDVCOiAvLyBbXHJcbiAgICAgICAgY2FzZSAweDVEOiAvLyBdXHJcbiAgICAgICAgY2FzZSAweDNBOiAvLyA6XHJcbiAgICAgICAgY2FzZSAweDNGOiAvLyA/XHJcbiAgICAgICAgY2FzZSAweDdFOiAvLyB+XHJcbiAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjgpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSAweDdCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXHJcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXHJcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29kZTIgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAvLyAnPScgKFUrMDAzRCkgbWFya3MgYW4gYXNzaWdubWVudCBvciBjb21wYXJpc29uIG9wZXJhdG9yLlxyXG4gICAgICAgICAgICBpZiAoY29kZTIgPT09IDB4M0QpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgyQjogLy8gK1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgyRDogLy8gLVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgyRjogLy8gL1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgzQzogLy8gPFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgzRTogLy8gPlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHg1RTogLy8gXlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHg3QzogLy8gfFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgyNTogLy8gJVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgyNjogLy8gJlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgyQTogLy8gKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDIxOiAvLyAhXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDNEOiAvLyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICE9PSBhbmQgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3I6ID4+Pj1cclxuICAgIGNoNCA9IHNvdXJjZS5zdWJzdHIoaW5kZXgsIDQpO1xyXG4gICAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XHJcbiAgICAgICAgaW5kZXggKz0gNDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxyXG4gICAgICAgICAgICB2YWx1ZTogY2g0LFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XHJcbiAgICBjaDMgPSBjaDQuc3Vic3RyKDAsIDMpO1xyXG4gICAgaWYgKGNoMyA9PT0gJz4+PicgfHwgY2gzID09PSAnPDw9JyB8fCBjaDMgPT09ICc+Pj0nKSB7XHJcbiAgICAgICAgaW5kZXggKz0gMztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxyXG4gICAgICAgICAgICB2YWx1ZTogY2gzLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIE90aGVyIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiArKyAtLSA8PCA+PiAmJiB8fFxyXG4gICAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcclxuICAgIGlmICgoY2gxID09PSBjaDJbMV0gJiYgKCcrLTw+JnwnLmluZGV4T2YoY2gxKSA+PSAwKSkgfHwgY2gyID09PSAnPT4nKSB7XHJcbiAgICAgICAgaW5kZXggKz0gMjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxyXG4gICAgICAgICAgICB2YWx1ZTogY2gyLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8ID4gPSAhICsgLSAqICUgJiB8IF4gL1xyXG4gICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XHJcbiAgICAgICAgKytpbmRleDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxyXG4gICAgICAgICAgICB2YWx1ZTogY2gxLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxufVxyXG4vLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXHJcbmZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XHJcbiAgICB2YXIgbnVtYmVyID0gJyc7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIWlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XHJcbiAgICB9XHJcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxuICAgIH1cclxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcclxuICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bWJlciwgMTYpLFxyXG4gICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXHJcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgIGVuZDogaW5kZXhcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCkge1xyXG4gICAgdmFyIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xyXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXHJcbiAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXHJcbiAgICAgICAgb2N0YWw6IHRydWUsXHJcbiAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcclxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcclxuICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgZW5kOiBpbmRleFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XHJcbiAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XHJcbiAgICBjaCA9IHNvdXJjZVtpbmRleF07XHJcbiAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLCAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XHJcbiAgICBzdGFydCA9IGluZGV4O1xyXG4gICAgbnVtYmVyID0gJyc7XHJcbiAgICBpZiAoY2ggIT09ICcuJykge1xyXG4gICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcclxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XHJcbiAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxyXG4gICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXHJcbiAgICAgICAgaWYgKG51bWJlciA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcclxuICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkhleExpdGVyYWwoc3RhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGVjaW1hbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnIHN1Y2ggYXMgJzA5JyBpcyBpbGxlZ2FsLlxyXG4gICAgICAgICAgICBpZiAoY2ggJiYgaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xyXG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XHJcbiAgICB9XHJcbiAgICBpZiAoY2ggPT09ICcuJykge1xyXG4gICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XHJcbiAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcclxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xyXG4gICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XHJcbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xyXG4gICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcclxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcclxuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xyXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXHJcbiAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcclxuICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxyXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICB9O1xyXG59XHJcbi8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xyXG5mdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcclxuICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgY29kZSwgdW5lc2NhcGVkLCByZXN0b3JlLCBvY3RhbCA9IGZhbHNlLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0TGluZVN0YXJ0O1xyXG4gICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcclxuICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xyXG4gICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xyXG4gICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLCAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XHJcbiAgICBzdGFydCA9IGluZGV4O1xyXG4gICAgKytpbmRleDtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xyXG4gICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuICAgICAgICAgICAgcXVvdGUgPSAnJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XHJcbiAgICAgICAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RyICs9IGNoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChxdW90ZSAhPT0gJycpIHtcclxuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFRva2VuLlN0cmluZ0xpdGVyYWwsXHJcbiAgICAgICAgdmFsdWU6IHN0cixcclxuICAgICAgICBvY3RhbDogb2N0YWwsXHJcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydExpbmVOdW1iZXIsXHJcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxyXG4gICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXHJcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgIGVuZDogaW5kZXhcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xyXG4gICAgdmFyIHZhbHVlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcclxuICAgIHZhciBjaCwgc3RyLCBjbGFzc01hcmtlciwgdGVybWluYXRlZCwgYm9keTtcclxuICAgIGNoID0gc291cmNlW2luZGV4XTtcclxuICAgIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcclxuICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcclxuICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XHJcbiAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcclxuICAgICAgICBzdHIgKz0gY2g7XHJcbiAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XHJcbiAgICAgICAgICAgIC8vIEVDTUEtMjYyIDcuOC41XHJcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ciArPSBjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbGFzc01hcmtlcikge1xyXG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdbJykge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuICAgIH1cclxuICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXHJcbiAgICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiBib2R5LFxyXG4gICAgICAgIGxpdGVyYWw6IHN0clxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XHJcbiAgICB2YXIgY2gsIHN0ciwgZmxhZ3MsIHJlc3RvcmU7XHJcbiAgICBzdHIgPSAnJztcclxuICAgIGZsYWdzID0gJyc7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XHJcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2luZGV4O1xyXG4gICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcclxuICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmbGFncyArPSBjaDtcclxuICAgICAgICAgICAgc3RyICs9IGNoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IGZsYWdzLFxyXG4gICAgICAgIGxpdGVyYWw6IHN0clxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xyXG4gICAgdmFyIHN0YXJ0LCBib2R5LCBmbGFncywgcGF0dGVybiwgdmFsdWU7XHJcbiAgICBsb29rYWhlYWQgPSBudWxsO1xyXG4gICAgc2tpcENvbW1lbnQoKTtcclxuICAgIHN0YXJ0ID0gaW5kZXg7XHJcbiAgICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcclxuICAgIGZsYWdzID0gc2NhblJlZ0V4cEZsYWdzKCk7XHJcbiAgICB2YWx1ZSA9IHRlc3RSZWdFeHAoYm9keS52YWx1ZSwgZmxhZ3MudmFsdWUpO1xyXG4gICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcclxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBpbmRleFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxpdGVyYWw6IGJvZHkubGl0ZXJhbCArIGZsYWdzLmxpdGVyYWwsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICBlbmQ6IGluZGV4XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNvbGxlY3RSZWdleCgpIHtcclxuICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xyXG4gICAgc2tpcENvbW1lbnQoKTtcclxuICAgIHBvcyA9IGluZGV4O1xyXG4gICAgbG9jID0ge1xyXG4gICAgICAgIHN0YXJ0OiB7XHJcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XHJcbiAgICBsb2MuZW5kID0ge1xyXG4gICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxyXG4gICAgfTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoIWV4dHJhLnRva2VuaXplKSB7XHJcbiAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXHJcbiAgICAgICAgaWYgKGV4dHJhLnRva2Vucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcvJyB8fCB0b2tlbi52YWx1ZSA9PT0gJy89Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxyXG4gICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxyXG4gICAgICAgICAgICBsb2M6IGxvY1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlZ2V4O1xyXG59XHJcbmZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcclxuICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XHJcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fFxyXG4gICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XHJcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xyXG4gICAgdmFyIHByZXZUb2tlbiwgY2hlY2tUb2tlbjtcclxuICAgIC8vIFVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cclxuICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoIXByZXZUb2tlbikge1xyXG4gICAgICAgIC8vIE5vdGhpbmcgYmVmb3JlIHRoYXQ6IGl0IGNhbm5vdCBiZSBhIGRpdmlzaW9uLlxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcclxuICAgIH1cclxuICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XHJcbiAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnKScpIHtcclxuICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuUGFyZW5Ub2tlbiAtIDFdO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tUb2tlbiAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiZcclxuICAgICAgICAgICAgICAgIChjaGVja1Rva2VuLnZhbHVlID09PSAnaWYnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3doaWxlJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICdmb3InIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3dpdGgnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnfScpIHtcclxuICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXHJcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxyXG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10gJiZcclxuICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDNdLnR5cGUgPT09ICdLZXl3b3JkJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0gJiZcclxuICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdLnR5cGUgPT09ICdLZXl3b3JkJykge1xyXG4gICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVja1Rva2VuIGRldGVybWluZXMgd2hldGhlciB0aGUgZnVuY3Rpb24gaXNcclxuICAgICAgICAgICAgLy8gYSBkZWNsYXJhdGlvbiBvciBhbiBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICBpZiAoRm5FeHByVG9rZW5zLmluZGV4T2YoY2hlY2tUb2tlbi52YWx1ZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gZXhwcmVzc2lvbi5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEl0IGlzIGEgZGVjbGFyYXRpb24uXHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnS2V5d29yZCcpIHtcclxuICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlKCkge1xyXG4gICAgdmFyIGNoO1xyXG4gICAgc2tpcENvbW1lbnQoKTtcclxuICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5FT0YsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxyXG4gICAgICAgICAgICBzdGFydDogaW5kZXgsXHJcbiAgICAgICAgICAgIGVuZDogaW5kZXhcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XHJcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XHJcbiAgICB9XHJcbiAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xyXG4gICAgaWYgKGNoID09PSAweDI4IHx8IGNoID09PSAweDI5IHx8IGNoID09PSAweDNCKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XHJcbiAgICB9XHJcbiAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxyXG4gICAgaWYgKGNoID09PSAweDI3IHx8IGNoID09PSAweDIyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XHJcbiAgICB9XHJcbiAgICAvLyBEb3QgKC4pIFUrMDAyRSBjYW4gYWxzbyBzdGFydCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgaGVuY2UgdGhlIG5lZWRcclxuICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cclxuICAgIGlmIChjaCA9PT0gMHgyRSkge1xyXG4gICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSkge1xyXG4gICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcclxuICAgIH1cclxuICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cclxuICAgIGlmIChleHRyYS50b2tlbml6ZSAmJiBjaCA9PT0gMHgyRikge1xyXG4gICAgICAgIHJldHVybiBhZHZhbmNlU2xhc2goKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcclxuICAgIHZhciBsb2MsIHRva2VuLCByYW5nZSwgdmFsdWU7XHJcbiAgICBza2lwQ29tbWVudCgpO1xyXG4gICAgbG9jID0ge1xyXG4gICAgICAgIHN0YXJ0OiB7XHJcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdG9rZW4gPSBhZHZhbmNlKCk7XHJcbiAgICBsb2MuZW5kID0ge1xyXG4gICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxyXG4gICAgfTtcclxuICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcclxuICAgICAgICB2YWx1ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcclxuICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICByYW5nZTogW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdLFxyXG4gICAgICAgICAgICBsb2M6IGxvY1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRva2VuO1xyXG59XHJcbmZ1bmN0aW9uIGxleCgpIHtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIHRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgaW5kZXggPSB0b2tlbi5lbmQ7XHJcbiAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcclxuICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcclxuICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcclxuICAgIGluZGV4ID0gdG9rZW4uZW5kO1xyXG4gICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XHJcbiAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XHJcbiAgICByZXR1cm4gdG9rZW47XHJcbn1cclxuZnVuY3Rpb24gcGVlaygpIHtcclxuICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0O1xyXG4gICAgcG9zID0gaW5kZXg7XHJcbiAgICBsaW5lID0gbGluZU51bWJlcjtcclxuICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xyXG4gICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xyXG4gICAgaW5kZXggPSBwb3M7XHJcbiAgICBsaW5lTnVtYmVyID0gbGluZTtcclxuICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xyXG59XHJcbmZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbHVtbikge1xyXG4gICAgdGhpcy5saW5lID0gbGluZTtcclxuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xyXG59XHJcbmZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIGxpbmUsIGNvbHVtbikge1xyXG4gICAgdGhpcy5zdGFydCA9IG5ldyBQb3NpdGlvbihzdGFydExpbmUsIHN0YXJ0Q29sdW1uKTtcclxuICAgIHRoaXMuZW5kID0gbmV3IFBvc2l0aW9uKGxpbmUsIGNvbHVtbik7XHJcbn1cclxuU3ludGF4VHJlZURlbGVnYXRlID0ge1xyXG4gICAgbmFtZTogJ1N5bnRheFRyZWUnLFxyXG4gICAgcHJvY2Vzc0NvbW1lbnQ6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIGxhc3RDaGlsZCwgdHJhaWxpbmdDb21tZW50cztcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguUHJvZ3JhbSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5ib2R5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXh0cmEudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChleHRyYS50cmFpbGluZ0NvbW1lbnRzWzBdLnJhbmdlWzBdID49IG5vZGUucmFuZ2VbMV0pIHtcclxuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBleHRyYS50cmFpbGluZ0NvbW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXh0cmEuYm90dG9tUmlnaHRTdGFjay5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICBleHRyYS5ib3R0b21SaWdodFN0YWNrW2V4dHJhLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoIC0gMV0udHJhaWxpbmdDb21tZW50cyAmJlxyXG4gICAgICAgICAgICAgICAgZXh0cmEuYm90dG9tUmlnaHRTdGFja1tleHRyYS5ib3R0b21SaWdodFN0YWNrLmxlbmd0aCAtIDFdLnRyYWlsaW5nQ29tbWVudHNbMF0ucmFuZ2VbMF0gPj0gbm9kZS5yYW5nZVsxXSkge1xyXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGV4dHJhLmJvdHRvbVJpZ2h0U3RhY2tbZXh0cmEuYm90dG9tUmlnaHRTdGFjay5sZW5ndGggLSAxXS50cmFpbGluZ0NvbW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGV4dHJhLmJvdHRvbVJpZ2h0U3RhY2tbZXh0cmEuYm90dG9tUmlnaHRTdGFjay5sZW5ndGggLSAxXS50cmFpbGluZ0NvbW1lbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVhdGluZyB0aGUgc3RhY2suXHJcbiAgICAgICAgd2hpbGUgKGV4dHJhLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoID4gMCAmJiBleHRyYS5ib3R0b21SaWdodFN0YWNrW2V4dHJhLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMF0gPj0gbm9kZS5yYW5nZVswXSkge1xyXG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBleHRyYS5ib3R0b21SaWdodFN0YWNrLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzICYmIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHNbbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxXS5yYW5nZVsxXSA8PSBub2RlLnJhbmdlWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleHRyYS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCAmJiBleHRyYS5sZWFkaW5nQ29tbWVudHNbZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDFdLnJhbmdlWzFdIDw9IG5vZGUucmFuZ2VbMF0pIHtcclxuICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBleHRyYS5sZWFkaW5nQ29tbWVudHM7XHJcbiAgICAgICAgICAgIGV4dHJhLmxlYWRpbmdDb21tZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cykge1xyXG4gICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHRyYS5ib3R0b21SaWdodFN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICB9LFxyXG4gICAgbWFya0VuZDogZnVuY3Rpb24gKG5vZGUsIHN0YXJ0VG9rZW4pIHtcclxuICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcclxuICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCBpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRyYS5sb2MpIHtcclxuICAgICAgICAgICAgbm9kZS5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRUb2tlbi5zdGFydExpbmVOdW1iZXIgPT09IHVuZGVmaW5lZCA/IHN0YXJ0VG9rZW4ubGluZU51bWJlciA6IHN0YXJ0VG9rZW4uc3RhcnRMaW5lTnVtYmVyLCBzdGFydFRva2VuLnN0YXJ0IC0gKHN0YXJ0VG9rZW4uc3RhcnRMaW5lU3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0VG9rZW4ubGluZVN0YXJ0IDogc3RhcnRUb2tlbi5zdGFydExpbmVTdGFydCksIGxpbmVOdW1iZXIsIGluZGV4IC0gbGluZVN0YXJ0KTtcclxuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzcyhub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29tbWVudChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9LFxyXG4gICAgcG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKGV4dHJhLnNvdXJjZSkge1xyXG4gICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSBleHRyYS5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkFycmF5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxyXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogcmlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJykgPyBTeW50YXguTG9naWNhbEV4cHJlc3Npb24gOlxyXG4gICAgICAgICAgICBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXHJcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxyXG4gICAgICAgICAgICBib2R5OiBib2R5XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVCcmVha1N0YXRlbWVudDogZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxyXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICBjYWxsZWU6IGNhbGxlZSxcclxuICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGFyZ3NcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUNhdGNoQ2xhdXNlOiBmdW5jdGlvbiAocGFyYW0sIGJvZHkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ2F0Y2hDbGF1c2UsXHJcbiAgICAgICAgICAgIHBhcmFtOiBwYXJhbSxcclxuICAgICAgICAgICAgYm9keTogYm9keVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgdGVzdDogdGVzdCxcclxuICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudCxcclxuICAgICAgICAgICAgYWx0ZXJuYXRlOiBhbHRlcm5hdGVcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUNvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRGVidWdnZXJTdGF0ZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZURvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChib2R5LCB0ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkRvV2hpbGVTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXHJcbiAgICAgICAgICAgIHRlc3Q6IHRlc3RcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUVtcHR5U3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkVtcHR5U3RhdGVtZW50XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LFxyXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRm9yU3RhdGVtZW50LFxyXG4gICAgICAgICAgICBpbml0OiBpbml0LFxyXG4gICAgICAgICAgICB0ZXN0OiB0ZXN0LFxyXG4gICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcclxuICAgICAgICAgICAgYm9keTogYm9keVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgYm9keSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Gb3JJblN0YXRlbWVudCxcclxuICAgICAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgICAgICBib2R5OiBib2R5LFxyXG4gICAgICAgICAgICBlYWNoOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb24sXHJcbiAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcbiAgICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcclxuICAgICAgICAgICAgYm9keTogYm9keSxcclxuICAgICAgICAgICAgcmVzdDogbnVsbCxcclxuICAgICAgICAgICAgZ2VuZXJhdG9yOiBmYWxzZSxcclxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxyXG4gICAgICAgICAgICBib2R5OiBib2R5LFxyXG4gICAgICAgICAgICByZXN0OiBudWxsLFxyXG4gICAgICAgICAgICBnZW5lcmF0b3I6IGZhbHNlLFxyXG4gICAgICAgICAgICBleHByZXNzaW9uOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlSWRlbnRpZmllcjogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgbmFtZTogbmFtZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlSWZTdGF0ZW1lbnQ6IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguSWZTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIHRlc3Q6IHRlc3QsXHJcbiAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQsXHJcbiAgICAgICAgICAgIGFsdGVybmF0ZTogYWx0ZXJuYXRlXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVMYWJlbGVkU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwsIGJvZHkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTGFiZWxlZFN0YXRlbWVudCxcclxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICBib2R5OiBib2R5XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVMaXRlcmFsOiBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcclxuICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxyXG4gICAgICAgICAgICByYXc6IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIGNvbXB1dGVkOiBhY2Nlc3NvciA9PT0gJ1snLFxyXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcclxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVOZXdFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5ld0V4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIGNhbGxlZTogY2FsbGVlLFxyXG4gICAgICAgICAgICAnYXJndW1lbnRzJzogYXJnc1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguT2JqZWN0RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlUG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxyXG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXHJcbiAgICAgICAgICAgIHByZWZpeDogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVByb2dyYW06IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb2dyYW0sXHJcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9wZXJ0eSxcclxuICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAga2luZDoga2luZFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguUmV0dXJuU3RhdGVtZW50LFxyXG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgZXhwcmVzc2lvbnM6IGV4cHJlc3Npb25zXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVTd2l0Y2hDYXNlOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Td2l0Y2hDYXNlLFxyXG4gICAgICAgICAgICB0ZXN0OiB0ZXN0LFxyXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVTd2l0Y2hTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LlN3aXRjaFN0YXRlbWVudCxcclxuICAgICAgICAgICAgZGlzY3JpbWluYW50OiBkaXNjcmltaW5hbnQsXHJcbiAgICAgICAgICAgIGNhc2VzOiBjYXNlc1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVGhpc0V4cHJlc3Npb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVGhpc0V4cHJlc3Npb25cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVRocm93U3RhdGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVGhyb3dTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVHJ5U3RhdGVtZW50OiBmdW5jdGlvbiAoYmxvY2ssIGd1YXJkZWRIYW5kbGVycywgaGFuZGxlcnMsIGZpbmFsaXplcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UcnlTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIGJsb2NrOiBibG9jayxcclxuICAgICAgICAgICAgZ3VhcmRlZEhhbmRsZXJzOiBndWFyZGVkSGFuZGxlcnMsXHJcbiAgICAgICAgICAgIGhhbmRsZXJzOiBoYW5kbGVycyxcclxuICAgICAgICAgICAgZmluYWxpemVyOiBmaW5hbGl6ZXJcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xyXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJysrJyB8fCBvcGVyYXRvciA9PT0gJy0tJykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxyXG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXHJcbiAgICAgICAgICAgIHByZWZpeDogdHJ1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gKGRlY2xhcmF0aW9ucywga2luZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGRlY2xhcmF0aW9ucyxcclxuICAgICAgICAgICAga2luZDoga2luZFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdG9yOiBmdW5jdGlvbiAoaWQsIGluaXQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yLFxyXG4gICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgIGluaXQ6IGluaXRcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAodGVzdCwgYm9keSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5XaGlsZVN0YXRlbWVudCxcclxuICAgICAgICAgICAgdGVzdDogdGVzdCxcclxuICAgICAgICAgICAgYm9keTogYm9keVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlV2l0aFN0YXRlbWVudDogZnVuY3Rpb24gKG9iamVjdCwgYm9keSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5XaXRoU3RhdGVtZW50LFxyXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcclxuICAgICAgICAgICAgYm9keTogYm9keVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cclxuZnVuY3Rpb24gcGVla0xpbmVUZXJtaW5hdG9yKCkge1xyXG4gICAgdmFyIHBvcywgbGluZSwgc3RhcnQsIGZvdW5kO1xyXG4gICAgcG9zID0gaW5kZXg7XHJcbiAgICBsaW5lID0gbGluZU51bWJlcjtcclxuICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xyXG4gICAgc2tpcENvbW1lbnQoKTtcclxuICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcclxuICAgIGluZGV4ID0gcG9zO1xyXG4gICAgbGluZU51bWJlciA9IGxpbmU7XHJcbiAgICBsaW5lU3RhcnQgPSBzdGFydDtcclxuICAgIHJldHVybiBmb3VuZDtcclxufVxyXG4vLyBUaHJvdyBhbiBleGNlcHRpb25cclxuZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBlcnJvciwgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKHdob2xlLCBpbmRleCkge1xyXG4gICAgICAgIGFzc2VydChpbmRleCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xyXG4gICAgICAgIHJldHVybiBhcmdzW2luZGV4XTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyB0b2tlbi5saW5lTnVtYmVyICsgJzogJyArIG1zZyk7XHJcbiAgICAgICAgZXJyb3IuaW5kZXggPSB0b2tlbi5zdGFydDtcclxuICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcclxuICAgICAgICBlcnJvci5jb2x1bW4gPSB0b2tlbi5zdGFydCAtIGxpbmVTdGFydCArIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZU51bWJlciArICc6ICcgKyBtc2cpO1xyXG4gICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XHJcbiAgICAgICAgZXJyb3IuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQgKyAxO1xyXG4gICAgfVxyXG4gICAgZXJyb3IuZGVzY3JpcHRpb24gPSBtc2c7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxufVxyXG5mdW5jdGlvbiB0aHJvd0Vycm9yVG9sZXJhbnQoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRocm93RXJyb3IuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcclxuICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXHJcbmZ1bmN0aW9uIHRocm93VW5leHBlY3RlZCh0b2tlbikge1xyXG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xyXG4gICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlcik7XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xyXG4gICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcclxuICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xyXG4gICAgICAgIGlmIChpc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxyXG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XHJcbn1cclxuLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcbmZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xyXG4gICAgdmFyIHRva2VuID0gbGV4KCk7XHJcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xyXG4gICAgfVxyXG59XHJcbi8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXHJcbi8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5mdW5jdGlvbiBleHBlY3RLZXl3b3JkKGtleXdvcmQpIHtcclxuICAgIHZhciB0b2tlbiA9IGxleCgpO1xyXG4gICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcclxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xyXG4gICAgfVxyXG59XHJcbi8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5mdW5jdGlvbiBtYXRjaCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XHJcbn1cclxuLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcclxuZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcclxuICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XHJcbn1cclxuLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxyXG5mdW5jdGlvbiBtYXRjaEFzc2lnbigpIHtcclxuICAgIHZhciBvcDtcclxuICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvcikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIG9wID0gbG9va2FoZWFkLnZhbHVlO1xyXG4gICAgcmV0dXJuIG9wID09PSAnPScgfHxcclxuICAgICAgICBvcCA9PT0gJyo9JyB8fFxyXG4gICAgICAgIG9wID09PSAnLz0nIHx8XHJcbiAgICAgICAgb3AgPT09ICclPScgfHxcclxuICAgICAgICBvcCA9PT0gJys9JyB8fFxyXG4gICAgICAgIG9wID09PSAnLT0nIHx8XHJcbiAgICAgICAgb3AgPT09ICc8PD0nIHx8XHJcbiAgICAgICAgb3AgPT09ICc+Pj0nIHx8XHJcbiAgICAgICAgb3AgPT09ICc+Pj49JyB8fFxyXG4gICAgICAgIG9wID09PSAnJj0nIHx8XHJcbiAgICAgICAgb3AgPT09ICdePScgfHxcclxuICAgICAgICBvcCA9PT0gJ3w9JztcclxufVxyXG5mdW5jdGlvbiBjb25zdW1lU2VtaWNvbG9uKCkge1xyXG4gICAgdmFyIGxpbmU7XHJcbiAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXHJcbiAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNCIHx8IG1hdGNoKCc7JykpIHtcclxuICAgICAgICBsZXgoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsaW5lID0gbGluZU51bWJlcjtcclxuICAgIHNraXBDb21tZW50KCk7XHJcbiAgICBpZiAobGluZU51bWJlciAhPT0gbGluZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GICYmICFtYXRjaCgnfScpKSB7XHJcbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XHJcbiAgICB9XHJcbn1cclxuLy8gUmV0dXJuIHRydWUgaWYgcHJvdmlkZWQgZXhwcmVzc2lvbiBpcyBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXHJcbmZ1bmN0aW9uIGlzTGVmdEhhbmRTaWRlKGV4cHIpIHtcclxuICAgIHJldHVybiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyIHx8IGV4cHIudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XHJcbn1cclxuLy8gMTEuMS40IEFycmF5IEluaXRpYWxpc2VyXHJcbmZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpIHtcclxuICAgIHZhciBlbGVtZW50cyA9IFtdLCBzdGFydFRva2VuO1xyXG4gICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcclxuICAgIGV4cGVjdCgnWycpO1xyXG4gICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XHJcbiAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcclxuICAgICAgICAgICAgbGV4KCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXgoKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZUFycmF5RXhwcmVzc2lvbihlbGVtZW50cyksIHN0YXJ0VG9rZW4pO1xyXG59XHJcbi8vIDExLjEuNSBPYmplY3QgSW5pdGlhbGlzZXJcclxuZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtLCBmaXJzdCkge1xyXG4gICAgdmFyIHByZXZpb3VzU3RyaWN0LCBib2R5LCBzdGFydFRva2VuO1xyXG4gICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG4gICAgaWYgKGZpcnN0ICYmIHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtWzBdLm5hbWUpKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0LCBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWUpO1xyXG4gICAgfVxyXG4gICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcbiAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW0sIFtdLCBib2R5KSwgc3RhcnRUb2tlbik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcclxuICAgIHZhciB0b2tlbiwgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICB0b2tlbiA9IGxleCgpO1xyXG4gICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcclxuICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxyXG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcclxuICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlTGl0ZXJhbCh0b2tlbiksIHN0YXJ0VG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlSWRlbnRpZmllcih0b2tlbi52YWx1ZSksIHN0YXJ0VG9rZW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHkoKSB7XHJcbiAgICB2YXIgdG9rZW4sIGtleSwgaWQsIHZhbHVlLCBwYXJhbSwgc3RhcnRUb2tlbjtcclxuICAgIHRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcclxuICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcbiAgICAgICAgLy8gUHJvcGVydHkgQXNzaWdubWVudDogR2V0dGVyIGFuZCBTZXR0ZXIuXHJcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiAhbWF0Y2goJzonKSkge1xyXG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcbiAgICAgICAgICAgIGV4cGVjdCgnKCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoJyknKTtcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByb3BlcnR5RnVuY3Rpb24oW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVQcm9wZXJ0eSgnZ2V0Jywga2V5LCB2YWx1ZSksIHN0YXJ0VG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdzZXQnICYmICFtYXRjaCgnOicpKSB7XHJcbiAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuICAgICAgICAgICAgZXhwZWN0KCcoJyk7XHJcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByb3BlcnR5RnVuY3Rpb24oW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyYW0gPSBbcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKV07XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoJ3NldCcsIGtleSwgdmFsdWUpLCBzdGFydFRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwZWN0KCc6Jyk7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoJ2luaXQnLCBpZCwgdmFsdWUpLCBzdGFydFRva2VuKTtcclxuICAgIH1cclxuICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xyXG4gICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcbiAgICAgICAgZXhwZWN0KCc6Jyk7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKSwgc3RhcnRUb2tlbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcclxuICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIHByb3BlcnR5LCBuYW1lLCBrZXksIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZywgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBleHBlY3QoJ3snKTtcclxuICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xyXG4gICAgICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmFtZSA9IHRvU3RyaW5nKHByb3BlcnR5LmtleS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtpbmQgPSAocHJvcGVydHkua2luZCA9PT0gJ2luaXQnKSA/IFByb3BlcnR5S2luZC5EYXRhIDogKHByb3BlcnR5LmtpbmQgPT09ICdnZXQnKSA/IFByb3BlcnR5S2luZC5HZXQgOiBQcm9wZXJ0eUtpbmQuU2V0O1xyXG4gICAgICAgIGtleSA9ICckJyArIG5hbWU7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcclxuICAgICAgICAgICAgaWYgKG1hcFtrZXldID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0RHVwbGljYXRlUHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFwW2tleV0gJiBraW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckdldFNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFwW2tleV0gfD0ga2luZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcFtrZXldID0ga2luZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcclxuICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcclxuICAgICAgICAgICAgZXhwZWN0KCcsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwZWN0KCd9Jyk7XHJcbiAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpLCBzdGFydFRva2VuKTtcclxufVxyXG4vLyAxMS4xLjYgVGhlIEdyb3VwaW5nIE9wZXJhdG9yXHJcbmZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xyXG4gICAgdmFyIGV4cHI7XHJcbiAgICBleHBlY3QoJygnKTtcclxuICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcclxuICAgIGV4cGVjdCgnKScpO1xyXG4gICAgcmV0dXJuIGV4cHI7XHJcbn1cclxuLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXHJcbmZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XHJcbiAgICB2YXIgdHlwZSwgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XHJcbiAgICBpZiAobWF0Y2goJygnKSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1hdGNoKCdbJykpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobWF0Y2goJ3snKSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XHJcbiAgICB9XHJcbiAgICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgaWYgKHR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcclxuICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlSWRlbnRpZmllcihsZXgoKS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XHJcbiAgICAgICAgaWYgKHN0cmljdCAmJiBsb29rYWhlYWQub2N0YWwpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwobGV4KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xyXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xyXG4gICAgICAgICAgICBsZXgoKTtcclxuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZVRoaXNFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsKSB7XHJcbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcclxuICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcclxuICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlTGl0ZXJhbCh0b2tlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xyXG4gICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xyXG4gICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVMaXRlcmFsKHRva2VuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwoY29sbGVjdFJlZ2V4KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwoc2NhblJlZ0V4cCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGVlaygpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGV4cHIsIHN0YXJ0VG9rZW4pO1xyXG59XHJcbi8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcclxuZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZXhwZWN0KCcoJyk7XHJcbiAgICBpZiAoIW1hdGNoKCcpJykpIHtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHBlY3QoJywnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBlY3QoJyknKTtcclxuICAgIHJldHVybiBhcmdzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcclxuICAgIHZhciB0b2tlbiwgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICB0b2tlbiA9IGxleCgpO1xyXG4gICAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xyXG4gICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVJZGVudGlmaWVyKHRva2VuLnZhbHVlKSwgc3RhcnRUb2tlbik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpIHtcclxuICAgIGV4cGVjdCgnLicpO1xyXG4gICAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XHJcbiAgICB2YXIgZXhwcjtcclxuICAgIGV4cGVjdCgnWycpO1xyXG4gICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgZXhwZWN0KCddJyk7XHJcbiAgICByZXR1cm4gZXhwcjtcclxufVxyXG5mdW5jdGlvbiBwYXJzZU5ld0V4cHJlc3Npb24oKSB7XHJcbiAgICB2YXIgY2FsbGVlLCBhcmdzLCBzdGFydFRva2VuO1xyXG4gICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcclxuICAgIGV4cGVjdEtleXdvcmQoJ25ldycpO1xyXG4gICAgY2FsbGVlID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCk7XHJcbiAgICBhcmdzID0gbWF0Y2goJygnKSA/IHBhcnNlQXJndW1lbnRzKCkgOiBbXTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZU5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSwgc3RhcnRUb2tlbik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xyXG4gICAgdmFyIHByZXZpb3VzQWxsb3dJbiwgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW47XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcclxuICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xyXG4gICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcclxuICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XHJcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xyXG4gICAgICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XHJcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgc3RhcnRUb2tlbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwcjtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSB7XHJcbiAgICB2YXIgcHJldmlvdXNBbGxvd0luLCBleHByLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xyXG4gICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcclxuICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcbiAgICB3aGlsZSAobWF0Y2goJy4nKSB8fCBtYXRjaCgnWycpKSB7XHJcbiAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XHJcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XHJcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxlZ2F0ZS5tYXJrRW5kKGV4cHIsIHN0YXJ0VG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHI7XHJcbn1cclxuLy8gMTEuMyBQb3N0Zml4IEV4cHJlc3Npb25zXHJcbmZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XHJcbiAgICB2YXIgZXhwciwgdG9rZW4sIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBleHByID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCk7XHJcbiAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcclxuICAgICAgICBpZiAoKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSAmJiAhcGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcclxuICAgICAgICAgICAgLy8gMTEuMy4xLCAxMS4zLjJcclxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZVBvc3RmaXhFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHI7XHJcbn1cclxuLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcclxuZnVuY3Rpb24gcGFyc2VVbmFyeUV4cHJlc3Npb24oKSB7XHJcbiAgICB2YXIgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XHJcbiAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcclxuICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcclxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgLy8gMTEuNC40LCAxMS40LjVcclxuICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0TEhTUHJlZml4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0xlZnRIYW5kU2lkZShleHByKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcclxuICAgICAgICBleHByID0gZGVsZWdhdGUubWFya0VuZChleHByLCBzdGFydFRva2VuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcclxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZVVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XHJcbiAgICAgICAgZXhwciA9IGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgc3RhcnRUb2tlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcclxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZVVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XHJcbiAgICAgICAgZXhwciA9IGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0RGVsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHI7XHJcbn1cclxuZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgYWxsb3dJbikge1xyXG4gICAgdmFyIHByZWMgPSAwO1xyXG4gICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgJ3x8JzpcclxuICAgICAgICAgICAgcHJlYyA9IDE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJyYmJzpcclxuICAgICAgICAgICAgcHJlYyA9IDI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3wnOlxyXG4gICAgICAgICAgICBwcmVjID0gMztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnXic6XHJcbiAgICAgICAgICAgIHByZWMgPSA0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICcmJzpcclxuICAgICAgICAgICAgcHJlYyA9IDU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJz09JzpcclxuICAgICAgICBjYXNlICchPSc6XHJcbiAgICAgICAgY2FzZSAnPT09JzpcclxuICAgICAgICBjYXNlICchPT0nOlxyXG4gICAgICAgICAgICBwcmVjID0gNjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnPCc6XHJcbiAgICAgICAgY2FzZSAnPic6XHJcbiAgICAgICAgY2FzZSAnPD0nOlxyXG4gICAgICAgIGNhc2UgJz49JzpcclxuICAgICAgICBjYXNlICdpbnN0YW5jZW9mJzpcclxuICAgICAgICAgICAgcHJlYyA9IDc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2luJzpcclxuICAgICAgICAgICAgcHJlYyA9IGFsbG93SW4gPyA3IDogMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnPDwnOlxyXG4gICAgICAgIGNhc2UgJz4+JzpcclxuICAgICAgICBjYXNlICc+Pj4nOlxyXG4gICAgICAgICAgICBwcmVjID0gODtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgIHByZWMgPSA5O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICcqJzpcclxuICAgICAgICBjYXNlICcvJzpcclxuICAgICAgICBjYXNlICclJzpcclxuICAgICAgICAgICAgcHJlYyA9IDExO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBwcmVjO1xyXG59XHJcbi8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXHJcbi8vIDExLjYgQWRkaXRpdmUgT3BlcmF0b3JzXHJcbi8vIDExLjcgQml0d2lzZSBTaGlmdCBPcGVyYXRvcnNcclxuLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xyXG4vLyAxMS45IEVxdWFsaXR5IE9wZXJhdG9yc1xyXG4vLyAxMS4xMCBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnNcclxuLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXHJcbmZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcclxuICAgIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xyXG4gICAgbWFya2VyID0gbG9va2FoZWFkO1xyXG4gICAgbGVmdCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcbiAgICB0b2tlbiA9IGxvb2thaGVhZDtcclxuICAgIHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBzdGF0ZS5hbGxvd0luKTtcclxuICAgIGlmIChwcmVjID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICB9XHJcbiAgICB0b2tlbi5wcmVjID0gcHJlYztcclxuICAgIGxleCgpO1xyXG4gICAgbWFya2VycyA9IFttYXJrZXIsIGxvb2thaGVhZF07XHJcbiAgICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcbiAgICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xyXG4gICAgd2hpbGUgKChwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShsb29rYWhlYWQsIHN0YXRlLmFsbG93SW4pKSA+IDApIHtcclxuICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXHJcbiAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSkge1xyXG4gICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xyXG4gICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XHJcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgZGVsZWdhdGUubWFya0VuZChleHByLCBtYXJrZXIpO1xyXG4gICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaGlmdC5cclxuICAgICAgICB0b2tlbiA9IGxleCgpO1xyXG4gICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xyXG4gICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xyXG4gICAgICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xyXG4gICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xyXG4gICAgICAgIHN0YWNrLnB1c2goZXhwcik7XHJcbiAgICB9XHJcbiAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxyXG4gICAgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XHJcbiAgICBleHByID0gc3RhY2tbaV07XHJcbiAgICBtYXJrZXJzLnBvcCgpO1xyXG4gICAgd2hpbGUgKGkgPiAxKSB7XHJcbiAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xyXG4gICAgICAgIGkgLT0gMjtcclxuICAgICAgICBtYXJrZXIgPSBtYXJrZXJzLnBvcCgpO1xyXG4gICAgICAgIGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgbWFya2VyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHByO1xyXG59XHJcbi8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXHJcbmZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xyXG4gICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xyXG4gICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcclxuICAgIGV4cHIgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKTtcclxuICAgIGlmIChtYXRjaCgnPycpKSB7XHJcbiAgICAgICAgbGV4KCk7XHJcbiAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcclxuICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcclxuICAgICAgICBjb25zZXF1ZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcbiAgICAgICAgZXhwZWN0KCc6Jyk7XHJcbiAgICAgICAgYWx0ZXJuYXRlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG4gICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcclxuICAgICAgICBkZWxlZ2F0ZS5tYXJrRW5kKGV4cHIsIHN0YXJ0VG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHI7XHJcbn1cclxuLy8gMTEuMTMgQXNzaWdubWVudCBPcGVyYXRvcnNcclxuZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcclxuICAgIHZhciB0b2tlbiwgbGVmdCwgcmlnaHQsIG5vZGUsIHN0YXJ0VG9rZW47XHJcbiAgICB0b2tlbiA9IGxvb2thaGVhZDtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBub2RlID0gbGVmdCA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XHJcbiAgICBpZiAobWF0Y2hBc3NpZ24oKSkge1xyXG4gICAgICAgIC8vIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cclxuICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGxlZnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDExLjEzLjFcclxuICAgICAgICBpZiAoc3RyaWN0ICYmIGxlZnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChsZWZ0Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0TEhTQXNzaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgcmlnaHQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgbm9kZSA9IGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odG9rZW4udmFsdWUsIGxlZnQsIHJpZ2h0KSwgc3RhcnRUb2tlbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG4vLyAxMS4xNCBDb21tYSBPcGVyYXRvclxyXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XHJcbiAgICB2YXIgZXhwciwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcclxuICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICBpZiAobWF0Y2goJywnKSkge1xyXG4gICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24oW2V4cHJdKTtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXgoKTtcclxuICAgICAgICAgICAgZXhwci5leHByZXNzaW9ucy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgc3RhcnRUb2tlbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwcjtcclxufVxyXG4vLyAxMi4xIEJsb2NrXHJcbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdCgpIHtcclxuICAgIHZhciBsaXN0ID0gW10sIHN0YXRlbWVudDtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGlmIChtYXRjaCgnfScpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpc3QucHVzaChzdGF0ZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VCbG9jaygpIHtcclxuICAgIHZhciBibG9jaywgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBleHBlY3QoJ3snKTtcclxuICAgIGJsb2NrID0gcGFyc2VTdGF0ZW1lbnRMaXN0KCk7XHJcbiAgICBleHBlY3QoJ30nKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZUJsb2NrU3RhdGVtZW50KGJsb2NrKSwgc3RhcnRUb2tlbik7XHJcbn1cclxuLy8gMTIuMiBWYXJpYWJsZSBTdGF0ZW1lbnRcclxuZnVuY3Rpb24gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSB7XHJcbiAgICB2YXIgdG9rZW4sIHN0YXJ0VG9rZW47XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgdG9rZW4gPSBsZXgoKTtcclxuICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZUlkZW50aWZpZXIodG9rZW4udmFsdWUpLCBzdGFydFRva2VuKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCkge1xyXG4gICAgdmFyIGluaXQgPSBudWxsLCBpZCwgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcbiAgICAvLyAxMi4yLjFcclxuICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG4gICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoa2luZCA9PT0gJ2NvbnN0Jykge1xyXG4gICAgICAgIGV4cGVjdCgnPScpO1xyXG4gICAgICAgIGluaXQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXRjaCgnPScpKSB7XHJcbiAgICAgICAgbGV4KCk7XHJcbiAgICAgICAgaW5pdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCksIHN0YXJ0VG9rZW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3Qoa2luZCkge1xyXG4gICAgdmFyIGxpc3QgPSBbXTtcclxuICAgIGRvIHtcclxuICAgICAgICBsaXN0LnB1c2gocGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKGtpbmQpKTtcclxuICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxleCgpO1xyXG4gICAgfSB3aGlsZSAoaW5kZXggPCBsZW5ndGgpO1xyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpIHtcclxuICAgIHZhciBkZWNsYXJhdGlvbnM7XHJcbiAgICBleHBlY3RLZXl3b3JkKCd2YXInKTtcclxuICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoKTtcclxuICAgIGNvbnN1bWVTZW1pY29sb24oKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpO1xyXG59XHJcbi8vIGtpbmQgbWF5IGJlIGBjb25zdGAgb3IgYGxldGBcclxuLy8gQm90aCBhcmUgZXhwZXJpbWVudGFsIGFuZCBub3QgaW4gdGhlIHNwZWNpZmljYXRpb24geWV0LlxyXG4vLyBzZWUgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpjb25zdFxyXG4vLyBhbmQgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpsZXRcclxuZnVuY3Rpb24gcGFyc2VDb25zdExldERlY2xhcmF0aW9uKGtpbmQpIHtcclxuICAgIHZhciBkZWNsYXJhdGlvbnMsIHN0YXJ0VG9rZW47XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgZXhwZWN0S2V5d29yZChraW5kKTtcclxuICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3Qoa2luZCk7XHJcbiAgICBjb25zdW1lU2VtaWNvbG9uKCk7XHJcbiAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCksIHN0YXJ0VG9rZW4pO1xyXG59XHJcbi8vIDEyLjMgRW1wdHkgU3RhdGVtZW50XHJcbmZ1bmN0aW9uIHBhcnNlRW1wdHlTdGF0ZW1lbnQoKSB7XHJcbiAgICBleHBlY3QoJzsnKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVFbXB0eVN0YXRlbWVudCgpO1xyXG59XHJcbi8vIDEyLjQgRXhwcmVzc2lvbiBTdGF0ZW1lbnRcclxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCkge1xyXG4gICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcclxuICAgIGNvbnN1bWVTZW1pY29sb24oKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xyXG59XHJcbi8vIDEyLjUgSWYgc3RhdGVtZW50XHJcbmZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlO1xyXG4gICAgZXhwZWN0S2V5d29yZCgnaWYnKTtcclxuICAgIGV4cGVjdCgnKCcpO1xyXG4gICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgZXhwZWN0KCcpJyk7XHJcbiAgICBjb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcclxuICAgIGlmIChtYXRjaEtleXdvcmQoJ2Vsc2UnKSkge1xyXG4gICAgICAgIGxleCgpO1xyXG4gICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlU3RhdGVtZW50KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhbHRlcm5hdGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XHJcbn1cclxuLy8gMTIuNiBJdGVyYXRpb24gU3RhdGVtZW50c1xyXG5mdW5jdGlvbiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgYm9keSwgdGVzdCwgb2xkSW5JdGVyYXRpb247XHJcbiAgICBleHBlY3RLZXl3b3JkKCdkbycpO1xyXG4gICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcclxuICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xyXG4gICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcclxuICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XHJcbiAgICBleHBlY3QoJygnKTtcclxuICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcclxuICAgIGV4cGVjdCgnKScpO1xyXG4gICAgaWYgKG1hdGNoKCc7JykpIHtcclxuICAgICAgICBsZXgoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVEb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlV2hpbGVTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgdGVzdCwgYm9keSwgb2xkSW5JdGVyYXRpb247XHJcbiAgICBleHBlY3RLZXl3b3JkKCd3aGlsZScpO1xyXG4gICAgZXhwZWN0KCcoJyk7XHJcbiAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XHJcbiAgICBleHBlY3QoJyknKTtcclxuICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XHJcbiAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcbiAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcclxuICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XHJcbiAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uKCkge1xyXG4gICAgdmFyIHRva2VuLCBkZWNsYXJhdGlvbnMsIHN0YXJ0VG9rZW47XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgdG9rZW4gPSBsZXgoKTtcclxuICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCB0b2tlbi52YWx1ZSksIHN0YXJ0VG9rZW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KCkge1xyXG4gICAgdmFyIGluaXQsIHRlc3QsIHVwZGF0ZSwgbGVmdCwgcmlnaHQsIGJvZHksIG9sZEluSXRlcmF0aW9uO1xyXG4gICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xyXG4gICAgZXhwZWN0S2V5d29yZCgnZm9yJyk7XHJcbiAgICBleHBlY3QoJygnKTtcclxuICAgIGlmIChtYXRjaCgnOycpKSB7XHJcbiAgICAgICAgbGV4KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCd2YXInKSB8fCBtYXRjaEtleXdvcmQoJ2xldCcpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgaW5pdCA9IHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbigpO1xyXG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBtYXRjaEtleXdvcmQoJ2luJykpIHtcclxuICAgICAgICAgICAgICAgIGxleCgpO1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgaW5pdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0xlZnRIYW5kU2lkZShpbml0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV4KCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdCgnOycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcclxuICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBlY3QoJzsnKTtcclxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcclxuICAgICAgICAgICAgdXBkYXRlID0gcGFyc2VFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwZWN0KCcpJyk7XHJcbiAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xyXG4gICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG4gICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XHJcbiAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xyXG4gICAgcmV0dXJuICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpID9cclxuICAgICAgICBkZWxlZ2F0ZS5jcmVhdGVGb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSA6XHJcbiAgICAgICAgZGVsZWdhdGUuY3JlYXRlRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpO1xyXG59XHJcbi8vIDEyLjcgVGhlIGNvbnRpbnVlIHN0YXRlbWVudFxyXG5mdW5jdGlvbiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KCkge1xyXG4gICAgdmFyIGxhYmVsID0gbnVsbCwga2V5O1xyXG4gICAgZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcclxuICAgIC8vIE9wdGltaXplIHRoZSBtb3N0IGNvbW1vbiBmb3JtOiAnY29udGludWU7Jy5cclxuICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0IpIHtcclxuICAgICAgICBsZXgoKTtcclxuICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxDb250aW51ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVDb250aW51ZVN0YXRlbWVudChudWxsKTtcclxuICAgIH1cclxuICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xyXG4gICAgICAgIGlmICghc3RhdGUuaW5JdGVyYXRpb24pIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUNvbnRpbnVlU3RhdGVtZW50KG51bGwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgbGFiZWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG4gICAgICAgIGtleSA9ICckJyArIGxhYmVsLm5hbWU7XHJcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGtleSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdW1lU2VtaWNvbG9uKCk7XHJcbiAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXN0YXRlLmluSXRlcmF0aW9uKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVDb250aW51ZVN0YXRlbWVudChsYWJlbCk7XHJcbn1cclxuLy8gMTIuOCBUaGUgYnJlYWsgc3RhdGVtZW50XHJcbmZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XHJcbiAgICBleHBlY3RLZXl3b3JkKCdicmVhaycpO1xyXG4gICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxyXG4gICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzQikge1xyXG4gICAgICAgIGxleCgpO1xyXG4gICAgICAgIGlmICghKHN0YXRlLmluSXRlcmF0aW9uIHx8IHN0YXRlLmluU3dpdGNoKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlQnJlYWtTdGF0ZW1lbnQobnVsbCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcclxuICAgICAgICBpZiAoIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUJyZWFrU3RhdGVtZW50KG51bGwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgbGFiZWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG4gICAgICAgIGtleSA9ICckJyArIGxhYmVsLm5hbWU7XHJcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGtleSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdW1lU2VtaWNvbG9uKCk7XHJcbiAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcclxuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUJyZWFrU3RhdGVtZW50KGxhYmVsKTtcclxufVxyXG4vLyAxMi45IFRoZSByZXR1cm4gc3RhdGVtZW50XHJcbmZ1bmN0aW9uIHBhcnNlUmV0dXJuU3RhdGVtZW50KCkge1xyXG4gICAgdmFyIGFyZ3VtZW50ID0gbnVsbDtcclxuICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xyXG4gICAgaWYgKCFzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xyXG4gICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XHJcbiAgICB9XHJcbiAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxyXG4gICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgyMCkge1xyXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpKSkge1xyXG4gICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xyXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQobnVsbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW1hdGNoKCc7JykpIHtcclxuICAgICAgICBpZiAoIW1hdGNoKCd9JykgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xyXG4gICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN1bWVTZW1pY29sb24oKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpO1xyXG59XHJcbi8vIDEyLjEwIFRoZSB3aXRoIHN0YXRlbWVudFxyXG5mdW5jdGlvbiBwYXJzZVdpdGhTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgb2JqZWN0LCBib2R5O1xyXG4gICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgIC8vIFRPRE8oaWthcmllbmF0b3IpOiBTaG91bGQgd2UgdXBkYXRlIHRoZSB0ZXN0IGNhc2VzIGluc3RlYWQ/XHJcbiAgICAgICAgc2tpcENvbW1lbnQoKTtcclxuICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdE1vZGVXaXRoKTtcclxuICAgIH1cclxuICAgIGV4cGVjdEtleXdvcmQoJ3dpdGgnKTtcclxuICAgIGV4cGVjdCgnKCcpO1xyXG4gICAgb2JqZWN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XHJcbiAgICBleHBlY3QoJyknKTtcclxuICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xyXG4gICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZVdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KTtcclxufVxyXG4vLyAxMi4xMCBUaGUgc3dpdGggc3RhdGVtZW50XHJcbmZ1bmN0aW9uIHBhcnNlU3dpdGNoQ2FzZSgpIHtcclxuICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50ID0gW10sIHN0YXRlbWVudCwgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBpZiAobWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuICAgICAgICBsZXgoKTtcclxuICAgICAgICB0ZXN0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcclxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XHJcbiAgICB9XHJcbiAgICBleHBlY3QoJzonKTtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGlmIChtYXRjaCgnfScpIHx8IG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IG1hdGNoS2V5d29yZCgnY2FzZScpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xyXG4gICAgICAgIGNvbnNlcXVlbnQucHVzaChzdGF0ZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSwgc3RhcnRUb2tlbik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgZGlzY3JpbWluYW50LCBjYXNlcywgY2xhdXNlLCBvbGRJblN3aXRjaCwgZGVmYXVsdEZvdW5kO1xyXG4gICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XHJcbiAgICBleHBlY3QoJygnKTtcclxuICAgIGRpc2NyaW1pbmFudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgZXhwZWN0KCcpJyk7XHJcbiAgICBleHBlY3QoJ3snKTtcclxuICAgIGNhc2VzID0gW107XHJcbiAgICBpZiAobWF0Y2goJ30nKSkge1xyXG4gICAgICAgIGxleCgpO1xyXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XHJcbiAgICB9XHJcbiAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xyXG4gICAgc3RhdGUuaW5Td2l0Y2ggPSB0cnVlO1xyXG4gICAgZGVmYXVsdEZvdW5kID0gZmFsc2U7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhdXNlID0gcGFyc2VTd2l0Y2hDYXNlKCk7XHJcbiAgICAgICAgaWYgKGNsYXVzZS50ZXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xyXG4gICAgfVxyXG4gICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcclxuICAgIGV4cGVjdCgnfScpO1xyXG4gICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZVN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKTtcclxufVxyXG4vLyAxMi4xMyBUaGUgdGhyb3cgc3RhdGVtZW50XHJcbmZ1bmN0aW9uIHBhcnNlVGhyb3dTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgYXJndW1lbnQ7XHJcbiAgICBleHBlY3RLZXl3b3JkKCd0aHJvdycpO1xyXG4gICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xyXG4gICAgfVxyXG4gICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcclxuICAgIGNvbnN1bWVTZW1pY29sb24oKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVUaHJvd1N0YXRlbWVudChhcmd1bWVudCk7XHJcbn1cclxuLy8gMTIuMTQgVGhlIHRyeSBzdGF0ZW1lbnRcclxuZnVuY3Rpb24gcGFyc2VDYXRjaENsYXVzZSgpIHtcclxuICAgIHZhciBwYXJhbSwgYm9keSwgc3RhcnRUb2tlbjtcclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBleHBlY3RLZXl3b3JkKCdjYXRjaCcpO1xyXG4gICAgZXhwZWN0KCcoJyk7XHJcbiAgICBpZiAobWF0Y2goJyknKSkge1xyXG4gICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xyXG4gICAgfVxyXG4gICAgcGFyYW0gPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG4gICAgLy8gMTIuMTQuMVxyXG4gICAgaWYgKHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RDYXRjaFZhcmlhYmxlKTtcclxuICAgIH1cclxuICAgIGV4cGVjdCgnKScpO1xyXG4gICAgYm9keSA9IHBhcnNlQmxvY2soKTtcclxuICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZUNhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSwgc3RhcnRUb2tlbik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VUcnlTdGF0ZW1lbnQoKSB7XHJcbiAgICB2YXIgYmxvY2ssIGhhbmRsZXJzID0gW10sIGZpbmFsaXplciA9IG51bGw7XHJcbiAgICBleHBlY3RLZXl3b3JkKCd0cnknKTtcclxuICAgIGJsb2NrID0gcGFyc2VCbG9jaygpO1xyXG4gICAgaWYgKG1hdGNoS2V5d29yZCgnY2F0Y2gnKSkge1xyXG4gICAgICAgIGhhbmRsZXJzLnB1c2gocGFyc2VDYXRjaENsYXVzZSgpKTtcclxuICAgIH1cclxuICAgIGlmIChtYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSkge1xyXG4gICAgICAgIGxleCgpO1xyXG4gICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2soKTtcclxuICAgIH1cclxuICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDAgJiYgIWZpbmFsaXplcikge1xyXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZVRyeVN0YXRlbWVudChibG9jaywgW10sIGhhbmRsZXJzLCBmaW5hbGl6ZXIpO1xyXG59XHJcbi8vIDEyLjE1IFRoZSBkZWJ1Z2dlciBzdGF0ZW1lbnRcclxuZnVuY3Rpb24gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpIHtcclxuICAgIGV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XHJcbiAgICBjb25zdW1lU2VtaWNvbG9uKCk7XHJcbiAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlRGVidWdnZXJTdGF0ZW1lbnQoKTtcclxufVxyXG4vLyAxMiBTdGF0ZW1lbnRzXHJcbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xyXG4gICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSwgZXhwciwgbGFiZWxlZEJvZHksIGtleSwgc3RhcnRUb2tlbjtcclxuICAgIGlmICh0eXBlID09PSBUb2tlbi5FT0YpIHtcclxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlQmxvY2soKTtcclxuICAgIH1cclxuICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XHJcbiAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xyXG4gICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJzsnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VFbXB0eVN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcclxuICAgICAgICAgICAgY2FzZSAnKCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xyXG4gICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlQ29udGludWVTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RvJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlRG9XaGlsZVN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcclxuICAgICAgICAgICAgY2FzZSAnZm9yJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlRm9yU3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xyXG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgICAgIGNhc2UgJ2lmJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlSWZTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JldHVybic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZVJldHVyblN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcclxuICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlU3dpdGNoU3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xyXG4gICAgICAgICAgICBjYXNlICd0aHJvdyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZVRocm93U3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xyXG4gICAgICAgICAgICBjYXNlICd0cnknOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VUcnlTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XHJcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZVZhcmlhYmxlU3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xyXG4gICAgICAgICAgICBjYXNlICd3aGlsZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZVdoaWxlU3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xyXG4gICAgICAgICAgICBjYXNlICd3aXRoJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlV2l0aFN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcclxuICAgIC8vIDEyLjEyIExhYmVsbGVkIFN0YXRlbWVudHNcclxuICAgIGlmICgoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikgJiYgbWF0Y2goJzonKSkge1xyXG4gICAgICAgIGxleCgpO1xyXG4gICAgICAgIGtleSA9ICckJyArIGV4cHIubmFtZTtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlJlZGVjbGFyYXRpb24sICdMYWJlbCcsIGV4cHIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0W2tleV0gPSB0cnVlO1xyXG4gICAgICAgIGxhYmVsZWRCb2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcclxuICAgICAgICBkZWxldGUgc3RhdGUubGFiZWxTZXRba2V5XTtcclxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVMYWJlbGVkU3RhdGVtZW50KGV4cHIsIGxhYmVsZWRCb2R5KSwgc3RhcnRUb2tlbik7XHJcbiAgICB9XHJcbiAgICBjb25zdW1lU2VtaWNvbG9uKCk7XHJcbiAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpLCBzdGFydFRva2VuKTtcclxufVxyXG4vLyAxMyBGdW5jdGlvbiBEZWZpbml0aW9uXHJcbmZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpIHtcclxuICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsIG9sZExhYmVsU2V0LCBvbGRJbkl0ZXJhdGlvbiwgb2xkSW5Td2l0Y2gsIG9sZEluRnVuY3Rpb25Cb2R5LCBzdGFydFRva2VuO1xyXG4gICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcclxuICAgIGV4cGVjdCgneycpO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcclxuICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XHJcbiAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcclxuICAgICAgICBpZiAoc291cmNlRWxlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XHJcbiAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9sZExhYmVsU2V0ID0gc3RhdGUubGFiZWxTZXQ7XHJcbiAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xyXG4gICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcclxuICAgIG9sZEluRnVuY3Rpb25Cb2R5ID0gc3RhdGUuaW5GdW5jdGlvbkJvZHk7XHJcbiAgICBzdGF0ZS5sYWJlbFNldCA9IHt9O1xyXG4gICAgc3RhdGUuaW5JdGVyYXRpb24gPSBmYWxzZTtcclxuICAgIHN0YXRlLmluU3dpdGNoID0gZmFsc2U7XHJcbiAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBleHBlY3QoJ30nKTtcclxuICAgIHN0YXRlLmxhYmVsU2V0ID0gb2xkTGFiZWxTZXQ7XHJcbiAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xyXG4gICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcclxuICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gb2xkSW5GdW5jdGlvbkJvZHk7XHJcbiAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVCbG9ja1N0YXRlbWVudChzb3VyY2VFbGVtZW50cyksIHN0YXJ0VG9rZW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCkge1xyXG4gICAgdmFyIHBhcmFtLCBwYXJhbXMgPSBbXSwgdG9rZW4sIHN0cmljdGVkLCBwYXJhbVNldCwga2V5LCBtZXNzYWdlO1xyXG4gICAgZXhwZWN0KCcoJyk7XHJcbiAgICBpZiAoIW1hdGNoKCcpJykpIHtcclxuICAgICAgICBwYXJhbVNldCA9IHt9O1xyXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcclxuICAgICAgICAgICAgcGFyYW0gPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG4gICAgICAgICAgICBrZXkgPSAnJCcgKyB0b2tlbi52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbVNldCwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmljdGVkID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghZmlyc3RSZXN0cmljdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1TZXQsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcclxuICAgICAgICAgICAgcGFyYW1TZXRba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHBlY3QoJywnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBlY3QoJyknKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcbiAgICAgICAgc3RyaWN0ZWQ6IHN0cmljdGVkLFxyXG4gICAgICAgIGZpcnN0UmVzdHJpY3RlZDogZmlyc3RSZXN0cmljdGVkLFxyXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCkge1xyXG4gICAgdmFyIGlkLCBwYXJhbXMgPSBbXSwgYm9keSwgdG9rZW4sIHN0cmljdGVkLCB0bXAsIGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSwgcHJldmlvdXNTdHJpY3QsIHN0YXJ0VG9rZW47XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuICAgIHRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG4gICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRtcCA9IHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCk7XHJcbiAgICBwYXJhbXMgPSB0bXAucGFyYW1zO1xyXG4gICAgc3RyaWN0ZWQgPSB0bXAuc3RyaWN0ZWQ7XHJcbiAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0bXAuZmlyc3RSZXN0cmljdGVkO1xyXG4gICAgaWYgKHRtcC5tZXNzYWdlKSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IHRtcC5tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XHJcbiAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcbiAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xyXG4gICAgICAgIHRocm93RXJyb3IoZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIGlmIChzdHJpY3QgJiYgc3RyaWN0ZWQpIHtcclxuICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcbiAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIFtdLCBib2R5KSwgc3RhcnRUb2tlbik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XHJcbiAgICB2YXIgdG9rZW4sIGlkID0gbnVsbCwgc3RyaWN0ZWQsIGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSwgdG1wLCBwYXJhbXMgPSBbXSwgYm9keSwgcHJldmlvdXNTdHJpY3QsIHN0YXJ0VG9rZW47XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuICAgIGlmICghbWF0Y2goJygnKSkge1xyXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuICAgICAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0bXAgPSBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpO1xyXG4gICAgcGFyYW1zID0gdG1wLnBhcmFtcztcclxuICAgIHN0cmljdGVkID0gdG1wLnN0cmljdGVkO1xyXG4gICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcclxuICAgIGlmICh0bXAubWVzc2FnZSkge1xyXG4gICAgICAgIG1lc3NhZ2UgPSB0bXAubWVzc2FnZTtcclxuICAgIH1cclxuICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xyXG4gICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG4gICAgaWYgKHN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcclxuICAgICAgICB0aHJvd0Vycm9yKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHN0cmljdGVkLCBtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG4gICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIFtdLCBib2R5KSwgc3RhcnRUb2tlbik7XHJcbn1cclxuLy8gMTQgUHJvZ3JhbVxyXG5mdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnQoKSB7XHJcbiAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcclxuICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xyXG4gICAgICAgICAgICBjYXNlICdjb25zdCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDb25zdExldERlY2xhcmF0aW9uKGxvb2thaGVhZC52YWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50cygpIHtcclxuICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcclxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xyXG4gICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xyXG4gICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xyXG4gICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzb3VyY2VFbGVtZW50cztcclxufVxyXG5mdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XHJcbiAgICB2YXIgYm9keSwgc3RhcnRUb2tlbjtcclxuICAgIHNraXBDb21tZW50KCk7XHJcbiAgICBwZWVrKCk7XHJcbiAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xyXG4gICAgc3RyaWN0ID0gZmFsc2U7XHJcbiAgICBib2R5ID0gcGFyc2VTb3VyY2VFbGVtZW50cygpO1xyXG4gICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlUHJvZ3JhbShib2R5KSwgc3RhcnRUb2tlbik7XHJcbn1cclxuZnVuY3Rpb24gZmlsdGVyVG9rZW5Mb2NhdGlvbigpIHtcclxuICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLnRva2Vucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xyXG4gICAgICAgIHRva2VuID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xyXG4gICAgICAgICAgICB0b2tlbi5yYW5nZSA9IGVudHJ5LnJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XHJcbiAgICAgICAgICAgIHRva2VuLmxvYyA9IGVudHJ5LmxvYztcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgfVxyXG4gICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdG9TdHJpbmcsIHRva2VuLCB0b2tlbnM7XHJcbiAgICB0b1N0cmluZyA9IFN0cmluZztcclxuICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xyXG4gICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcclxuICAgIH1cclxuICAgIGRlbGVnYXRlID0gU3ludGF4VHJlZURlbGVnYXRlO1xyXG4gICAgc291cmNlID0gY29kZTtcclxuICAgIGluZGV4ID0gMDtcclxuICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XHJcbiAgICBsaW5lU3RhcnQgPSAwO1xyXG4gICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcclxuICAgIGxvb2thaGVhZCA9IG51bGw7XHJcbiAgICBzdGF0ZSA9IHtcclxuICAgICAgICBhbGxvd0luOiB0cnVlLFxyXG4gICAgICAgIGxhYmVsU2V0OiB7fSxcclxuICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXHJcbiAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxyXG4gICAgICAgIGluU3dpdGNoOiBmYWxzZSxcclxuICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMVxyXG4gICAgfTtcclxuICAgIGV4dHJhID0ge307XHJcbiAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAvLyBPZiBjb3Vyc2Ugd2UgY29sbGVjdCB0b2tlbnMgaGVyZS5cclxuICAgIG9wdGlvbnMudG9rZW5zID0gdHJ1ZTtcclxuICAgIGV4dHJhLnRva2VucyA9IFtdO1xyXG4gICAgZXh0cmEudG9rZW5pemUgPSB0cnVlO1xyXG4gICAgLy8gVGhlIGZvbGxvd2luZyB0d28gZmllbGRzIGFyZSBuZWNlc3NhcnkgdG8gY29tcHV0ZSB0aGUgUmVnZXggdG9rZW5zLlxyXG4gICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcclxuICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gLTE7XHJcbiAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xyXG4gICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XHJcbiAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcclxuICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcGVlaygpO1xyXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYS50b2tlbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgd2hpbGUgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGxleEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcclxuICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChsZXhFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBicmVhayBvbiB0aGUgZmlyc3QgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGxleEVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcclxuICAgICAgICB0b2tlbnMgPSBleHRyYS50b2tlbnM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5jb21tZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdG9rZW5zLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGV4dHJhID0ge307XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9rZW5zO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XHJcbiAgICB0b1N0cmluZyA9IFN0cmluZztcclxuICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xyXG4gICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcclxuICAgIH1cclxuICAgIGRlbGVnYXRlID0gU3ludGF4VHJlZURlbGVnYXRlO1xyXG4gICAgc291cmNlID0gY29kZTtcclxuICAgIGluZGV4ID0gMDtcclxuICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XHJcbiAgICBsaW5lU3RhcnQgPSAwO1xyXG4gICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcclxuICAgIGxvb2thaGVhZCA9IG51bGw7XHJcbiAgICBzdGF0ZSA9IHtcclxuICAgICAgICBhbGxvd0luOiB0cnVlLFxyXG4gICAgICAgIGxhYmVsU2V0OiB7fSxcclxuICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXHJcbiAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxyXG4gICAgICAgIGluU3dpdGNoOiBmYWxzZSxcclxuICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMVxyXG4gICAgfTtcclxuICAgIGV4dHJhID0ge307XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcclxuICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xyXG4gICAgICAgIGV4dHJhLmF0dGFjaENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuYXR0YWNoQ29tbWVudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmF0dGFjaENvbW1lbnQ7XHJcbiAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGV4dHJhLnNvdXJjZSA9IHRvU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9rZW5zKSB7XHJcbiAgICAgICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuY29tbWVudCkge1xyXG4gICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XHJcbiAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xyXG4gICAgICAgICAgICBleHRyYS5yYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIGV4dHJhLmJvdHRvbVJpZ2h0U3RhY2sgPSBbXTtcclxuICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmNvbW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBwcm9ncmFtLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XHJcbiAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZXh0cmEgPSB7fTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9ncmFtO1xyXG59XHJcbi8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxyXG5leHBvcnQgdmFyIHZlcnNpb24gPSAnMS4yLjInO1xyXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc3ByaW1hLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/esprima.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/handlers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/handlers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Handlers: () => (/* binding */ Handlers)\n/* harmony export */ });\n/* harmony import */ var _esprima__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esprima */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/esprima.js\");\n/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/slice.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! . */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/index.js\");\n/* harmony import */ var static_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! static-eval */ \"(ssr)/./node_modules/static-eval/index.js\");\n/* harmony import */ var static_eval__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(static_eval__WEBPACK_IMPORTED_MODULE_3__);\n\r\n\r\n\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction traverser(recurse) {\r\n    return function (partial, ref, passable, count) {\r\n        var value = partial.value;\r\n        var path = partial.path;\r\n        var results = [];\r\n        var descend = function (value, path) {\r\n            if (is_array(value)) {\r\n                value.forEach(function (element, index) {\r\n                    if (results.length >= count) {\r\n                        return;\r\n                    }\r\n                    if (passable(index, element, ref)) {\r\n                        results.push({ path: path.concat(index), value: element });\r\n                    }\r\n                });\r\n                value.forEach(function (element, index) {\r\n                    if (results.length >= count) {\r\n                        return;\r\n                    }\r\n                    if (recurse) {\r\n                        descend(element, path.concat(index));\r\n                    }\r\n                });\r\n            }\r\n            else if (is_object(value)) {\r\n                Object.keys(value).forEach(function (k) {\r\n                    if (results.length >= count) {\r\n                        return;\r\n                    }\r\n                    if (passable(k, value[k], ref)) {\r\n                        results.push({ path: path.concat(k), value: value[k] });\r\n                    }\r\n                });\r\n                Object.keys(value).forEach(function (k) {\r\n                    if (results.length >= count) {\r\n                        return;\r\n                    }\r\n                    if (recurse) {\r\n                        descend(value[k], path.concat(k));\r\n                    }\r\n                });\r\n            }\r\n        }.bind(this);\r\n        descend(value, path);\r\n        return results;\r\n    };\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction evaluate(ast, vars) {\r\n    try {\r\n        return static_eval__WEBPACK_IMPORTED_MODULE_3___default()(ast, vars);\r\n    }\r\n    catch (e) {\r\n    }\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction _descend(passable) {\r\n    return function (component, partial, count) {\r\n        return this.descend(partial, component.expression.value, passable, count);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction _traverse(passable) {\r\n    return function (component, partial, count) {\r\n        return this.traverse(partial, component.expression.value, passable, count);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction unique(results) {\r\n    results = results.filter(function (d) { return d; });\r\n    return uniq(results, function (r) { return r.path.map(function (c) { return String(c).replace('-', '--'); }).join('-'); });\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction _parse_nullable_int(val) {\r\n    var sval = String(val);\r\n    return sval.match(/^-?[0-9]+$/) ? parseInt(sval) : null;\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction is_array(val) {\r\n    return Array.isArray(val);\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction is_object(val) {\r\n    // is this a non-array, non-null object?\r\n    return val && !(val instanceof Array) && val instanceof Object;\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction eval_recurse(partial, src, template) {\r\n    var ast = _esprima__WEBPACK_IMPORTED_MODULE_0__.parse(src).body[0].expression;\r\n    var value = evaluate(ast, { '@': partial.value });\r\n    var path = template.replace(/\\{\\{\\s*value\\s*\\}\\}/g, value);\r\n    var results = ___WEBPACK_IMPORTED_MODULE_2__.JSONPath.nodes(partial.value, path);\r\n    results.forEach(function (r) {\r\n        r.path = partial.path.concat(r.path.slice(1));\r\n    });\r\n    return results;\r\n}\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nvar Handlers = /** @class */ (function () {\r\n    function Handlers() {\r\n        this._fns = {\r\n            'member-child-identifier': function (component, partial) {\r\n                var key = component.expression.value;\r\n                var value = partial.value;\r\n                if (value instanceof Object && key in value) {\r\n                    return [{ value: value[key], path: partial.path.concat(key) }];\r\n                }\r\n            },\r\n            'member-descendant-identifier': _traverse(function (key, value, ref) { return key == ref; }),\r\n            'subscript-child-numeric_literal': _descend(function (key, value, ref) { return key === ref; }),\r\n            'member-child-numeric_literal': _descend(function (key, value, ref) { return String(key) === String(ref); }),\r\n            'subscript-descendant-numeric_literal': _traverse(function (key, value, ref) { return key === ref; }),\r\n            'member-child-wildcard': _descend(function () { return true; }),\r\n            'member-descendant-wildcard': _traverse(function () { return true; }),\r\n            'subscript-descendant-wildcard': _traverse(function () { return true; }),\r\n            'subscript-child-wildcard': _descend(function () { return true; }),\r\n            'subscript-child-slice': function (component, partial) {\r\n                if (is_array(partial.value)) {\r\n                    var args = component.expression.value.split(':').map(_parse_nullable_int);\r\n                    var values = partial.value.map(function (v, i) { return { value: v, path: partial.path.concat(i) }; });\r\n                    return _slice__WEBPACK_IMPORTED_MODULE_1__.slice.apply(null, [values].concat(args));\r\n                }\r\n            },\r\n            'subscript-child-union': function (component, partial) {\r\n                var results = [];\r\n                component.expression.value.forEach(function (component) {\r\n                    var _component = { operation: 'subscript', scope: 'child', expression: component.expression };\r\n                    var handler = this.resolve(_component);\r\n                    var _results = handler(_component, partial);\r\n                    if (_results) {\r\n                        results = results.concat(_results);\r\n                    }\r\n                }, this);\r\n                return unique(results);\r\n            },\r\n            'subscript-descendant-union': function (component, partial, count) {\r\n                var self = this;\r\n                var results = [];\r\n                var nodes = ___WEBPACK_IMPORTED_MODULE_2__.JSONPath.nodes(partial, '$..*').slice(1);\r\n                nodes.forEach(function (node) {\r\n                    if (results.length >= count)\r\n                        return;\r\n                    component.expression.value.forEach(function (component) {\r\n                        var _component = { operation: 'subscript', scope: 'child', expression: component.expression };\r\n                        var handler = self.resolve(_component);\r\n                        var _results = handler(_component, node);\r\n                        results = results.concat(_results);\r\n                    });\r\n                });\r\n                return unique(results);\r\n            },\r\n            'subscript-child-filter_expression': function (component, partial, count) {\r\n                // slice out the expression from ?(expression)\r\n                var src = component.expression.value.slice(2, -1);\r\n                var ast = _esprima__WEBPACK_IMPORTED_MODULE_0__.parse(src).body[0].expression;\r\n                var passable = function (key, value) {\r\n                    return evaluate(ast, { '@': value });\r\n                };\r\n                return this.descend(partial, null, passable, count);\r\n            },\r\n            'subscript-descendant-filter_expression': function (component, partial, count) {\r\n                // slice out the expression from ?(expression)\r\n                var src = component.expression.value.slice(2, -1);\r\n                var ast = _esprima__WEBPACK_IMPORTED_MODULE_0__.parse(src).body[0].expression;\r\n                var passable = function (key, value) {\r\n                    return evaluate(ast, { '@': value });\r\n                };\r\n                return this.traverse(partial, null, passable, count);\r\n            },\r\n            'subscript-child-script_expression': function (component, partial) {\r\n                var exp = component.expression.value.slice(1, -1);\r\n                return eval_recurse(partial, exp, '$[{{value}}]');\r\n            },\r\n            'member-child-script_expression': function (component, partial) {\r\n                var exp = component.expression.value.slice(1, -1);\r\n                return eval_recurse(partial, exp, '$.{{value}}');\r\n            },\r\n            'member-descendant-script_expression': function (component, partial) {\r\n                var exp = component.expression.value.slice(1, -1);\r\n                return eval_recurse(partial, exp, '$..value');\r\n            }\r\n        };\r\n        this.initialize();\r\n    }\r\n    Handlers.prototype.initialize = function () {\r\n        this.traverse = traverser(true);\r\n        this.descend = traverser();\r\n        this._fns['subscript-child-string_literal'] =\r\n            this._fns['member-child-identifier'];\r\n        this._fns['member-descendant-numeric_literal'] =\r\n            this._fns['subscript-descendant-string_literal'] =\r\n                this._fns['member-descendant-identifier'];\r\n    };\r\n    Handlers.prototype.resolve = function (component) {\r\n        var key = [component.operation, component.scope, component.expression.type].join('-');\r\n        var method = this._fns[key];\r\n        if (!method)\r\n            throw new Error(\"couldn't resolve key: \" + key);\r\n        return method.bind(this);\r\n    };\r\n    Handlers.prototype.register = function (key, handler) {\r\n        if (!(handler instanceof Function)) {\r\n            throw new Error(\"handler must be a function\");\r\n        }\r\n        this._fns[key] = handler;\r\n    };\r\n    return Handlers;\r\n}());\r\n\r\nfunction uniq(array, iteratee) {\r\n    var result = [];\r\n    var seen = [];\r\n    for (var i = 0, length = array === null || array === void 0 ? void 0 : array.length; i < length; i++) {\r\n        var value = array[i], computed = iteratee ? iteratee(value, i) : value;\r\n        if (!seen.includes(computed)) {\r\n            seen.push(computed);\r\n            result.push(value);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=handlers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vaGFuZGxlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXFDO0FBQ0w7QUFDSDtBQUNPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBDQUEwQztBQUNqRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZELHdDQUF3QyxpQ0FBaUMsc0NBQXNDLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQWE7QUFDM0IsZ0NBQWdDLG9CQUFvQjtBQUNwRCxtQ0FBbUMsRUFBRSxhQUFhLEVBQUU7QUFDcEQsa0JBQWtCLHVDQUFRO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQW1EO0FBQ2pGO0FBQ0EsYUFBYTtBQUNiLG1GQUFtRixvQkFBb0I7QUFDdkcscUZBQXFGLHFCQUFxQjtBQUMxRyxrRkFBa0YscUNBQXFDO0FBQ3ZILDJGQUEyRixxQkFBcUI7QUFDaEgsNERBQTRELGNBQWM7QUFDMUUsa0VBQWtFLGNBQWM7QUFDaEYscUVBQXFFLGNBQWM7QUFDbkYsK0RBQStELGNBQWM7QUFDN0U7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFNBQVMsMkNBQTJDO0FBQ3pILDJCQUEyQix5Q0FBSztBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkNBQWE7QUFDdkM7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQ0FBYTtBQUN2QztBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlELGFBQWE7QUFDYjtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFlBQVk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHdoaXN0bGV4L2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bhc3Ryb25hdXRsYWJzL2pzb25wYXRoL2Rpc3QuZXNtL2hhbmRsZXJzLmpzPzJhNzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWVzcHJpbSBmcm9tICcuL2VzcHJpbWEnO1xyXG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vc2xpY2UnO1xyXG5pbXBvcnQgeyBKU09OUGF0aCB9IGZyb20gJy4nO1xyXG5pbXBvcnQgX2V2YWx1YXRlIGZyb20gJ3N0YXRpYy1ldmFsJztcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZXIocmVjdXJzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJ0aWFsLCByZWYsIHBhc3NhYmxlLCBjb3VudCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRpYWwudmFsdWU7XHJcbiAgICAgICAgdmFyIHBhdGggPSBwYXJ0aWFsLnBhdGg7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICB2YXIgZGVzY2VuZCA9IGZ1bmN0aW9uICh2YWx1ZSwgcGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoaXNfYXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+PSBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzYWJsZShpbmRleCwgZWxlbWVudCwgcmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyBwYXRoOiBwYXRoLmNvbmNhdChpbmRleCksIHZhbHVlOiBlbGVtZW50IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKGVsZW1lbnQsIHBhdGguY29uY2F0KGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNfb2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzc2FibGUoaywgdmFsdWVba10sIHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgcGF0aDogcGF0aC5jb25jYXQoayksIHZhbHVlOiB2YWx1ZVtrXSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID49IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY2VuZCh2YWx1ZVtrXSwgcGF0aC5jb25jYXQoaykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIGRlc2NlbmQodmFsdWUsIHBhdGgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmZ1bmN0aW9uIGV2YWx1YXRlKGFzdCwgdmFycykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gX2V2YWx1YXRlKGFzdCwgdmFycyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGhpZGRlblxyXG4gKi9cclxuZnVuY3Rpb24gX2Rlc2NlbmQocGFzc2FibGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoY29tcG9uZW50LCBwYXJ0aWFsLCBjb3VudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NlbmQocGFydGlhbCwgY29tcG9uZW50LmV4cHJlc3Npb24udmFsdWUsIHBhc3NhYmxlLCBjb3VudCk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGhpZGRlblxyXG4gKi9cclxuZnVuY3Rpb24gX3RyYXZlcnNlKHBhc3NhYmxlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbXBvbmVudCwgcGFydGlhbCwgY291bnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmF2ZXJzZShwYXJ0aWFsLCBjb21wb25lbnQuZXhwcmVzc2lvbi52YWx1ZSwgcGFzc2FibGUsIGNvdW50KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmlxdWUocmVzdWx0cykge1xyXG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkOyB9KTtcclxuICAgIHJldHVybiB1bmlxKHJlc3VsdHMsIGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnBhdGgubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBTdHJpbmcoYykucmVwbGFjZSgnLScsICctLScpOyB9KS5qb2luKCctJyk7IH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGhpZGRlblxyXG4gKi9cclxuZnVuY3Rpb24gX3BhcnNlX251bGxhYmxlX2ludCh2YWwpIHtcclxuICAgIHZhciBzdmFsID0gU3RyaW5nKHZhbCk7XHJcbiAgICByZXR1cm4gc3ZhbC5tYXRjaCgvXi0/WzAtOV0rJC8pID8gcGFyc2VJbnQoc3ZhbCkgOiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGhpZGRlblxyXG4gKi9cclxuZnVuY3Rpb24gaXNfYXJyYXkodmFsKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGhpZGRlblxyXG4gKi9cclxuZnVuY3Rpb24gaXNfb2JqZWN0KHZhbCkge1xyXG4gICAgLy8gaXMgdGhpcyBhIG5vbi1hcnJheSwgbm9uLW51bGwgb2JqZWN0P1xyXG4gICAgcmV0dXJuIHZhbCAmJiAhKHZhbCBpbnN0YW5jZW9mIEFycmF5KSAmJiB2YWwgaW5zdGFuY2VvZiBPYmplY3Q7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5mdW5jdGlvbiBldmFsX3JlY3Vyc2UocGFydGlhbCwgc3JjLCB0ZW1wbGF0ZSkge1xyXG4gICAgdmFyIGFzdCA9IGFlc3ByaW0ucGFyc2Uoc3JjKS5ib2R5WzBdLmV4cHJlc3Npb247XHJcbiAgICB2YXIgdmFsdWUgPSBldmFsdWF0ZShhc3QsIHsgJ0AnOiBwYXJ0aWFsLnZhbHVlIH0pO1xyXG4gICAgdmFyIHBhdGggPSB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHtcXHtcXHMqdmFsdWVcXHMqXFx9XFx9L2csIHZhbHVlKTtcclxuICAgIHZhciByZXN1bHRzID0gSlNPTlBhdGgubm9kZXMocGFydGlhbC52YWx1ZSwgcGF0aCk7XHJcbiAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICByLnBhdGggPSBwYXJ0aWFsLnBhdGguY29uY2F0KHIucGF0aC5zbGljZSgxKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGhpZGRlblxyXG4gKi9cclxudmFyIEhhbmRsZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGFuZGxlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fZm5zID0ge1xyXG4gICAgICAgICAgICAnbWVtYmVyLWNoaWxkLWlkZW50aWZpZXInOiBmdW5jdGlvbiAoY29tcG9uZW50LCBwYXJ0aWFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gY29tcG9uZW50LmV4cHJlc3Npb24udmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0aWFsLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbeyB2YWx1ZTogdmFsdWVba2V5XSwgcGF0aDogcGFydGlhbC5wYXRoLmNvbmNhdChrZXkpIH1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnbWVtYmVyLWRlc2NlbmRhbnQtaWRlbnRpZmllcic6IF90cmF2ZXJzZShmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcmVmKSB7IHJldHVybiBrZXkgPT0gcmVmOyB9KSxcclxuICAgICAgICAgICAgJ3N1YnNjcmlwdC1jaGlsZC1udW1lcmljX2xpdGVyYWwnOiBfZGVzY2VuZChmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcmVmKSB7IHJldHVybiBrZXkgPT09IHJlZjsgfSksXHJcbiAgICAgICAgICAgICdtZW1iZXItY2hpbGQtbnVtZXJpY19saXRlcmFsJzogX2Rlc2NlbmQoZnVuY3Rpb24gKGtleSwgdmFsdWUsIHJlZikgeyByZXR1cm4gU3RyaW5nKGtleSkgPT09IFN0cmluZyhyZWYpOyB9KSxcclxuICAgICAgICAgICAgJ3N1YnNjcmlwdC1kZXNjZW5kYW50LW51bWVyaWNfbGl0ZXJhbCc6IF90cmF2ZXJzZShmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcmVmKSB7IHJldHVybiBrZXkgPT09IHJlZjsgfSksXHJcbiAgICAgICAgICAgICdtZW1iZXItY2hpbGQtd2lsZGNhcmQnOiBfZGVzY2VuZChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KSxcclxuICAgICAgICAgICAgJ21lbWJlci1kZXNjZW5kYW50LXdpbGRjYXJkJzogX3RyYXZlcnNlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pLFxyXG4gICAgICAgICAgICAnc3Vic2NyaXB0LWRlc2NlbmRhbnQtd2lsZGNhcmQnOiBfdHJhdmVyc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSksXHJcbiAgICAgICAgICAgICdzdWJzY3JpcHQtY2hpbGQtd2lsZGNhcmQnOiBfZGVzY2VuZChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KSxcclxuICAgICAgICAgICAgJ3N1YnNjcmlwdC1jaGlsZC1zbGljZSc6IGZ1bmN0aW9uIChjb21wb25lbnQsIHBhcnRpYWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc19hcnJheShwYXJ0aWFsLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gY29tcG9uZW50LmV4cHJlc3Npb24udmFsdWUuc3BsaXQoJzonKS5tYXAoX3BhcnNlX251bGxhYmxlX2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHBhcnRpYWwudmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB7IHZhbHVlOiB2LCBwYXRoOiBwYXJ0aWFsLnBhdGguY29uY2F0KGkpIH07IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5hcHBseShudWxsLCBbdmFsdWVzXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnc3Vic2NyaXB0LWNoaWxkLXVuaW9uJzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcGFydGlhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5leHByZXNzaW9uLnZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfY29tcG9uZW50ID0geyBvcGVyYXRpb246ICdzdWJzY3JpcHQnLCBzY29wZTogJ2NoaWxkJywgZXhwcmVzc2lvbjogY29tcG9uZW50LmV4cHJlc3Npb24gfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMucmVzb2x2ZShfY29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdHMgPSBoYW5kbGVyKF9jb21wb25lbnQsIHBhcnRpYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoX3Jlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuaXF1ZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ3N1YnNjcmlwdC1kZXNjZW5kYW50LXVuaW9uJzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcGFydGlhbCwgY291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBKU09OUGF0aC5ub2RlcyhwYXJ0aWFsLCAnJC4uKicpLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+PSBjb3VudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5leHByZXNzaW9uLnZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbXBvbmVudCA9IHsgb3BlcmF0aW9uOiAnc3Vic2NyaXB0Jywgc2NvcGU6ICdjaGlsZCcsIGV4cHJlc3Npb246IGNvbXBvbmVudC5leHByZXNzaW9uIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gc2VsZi5yZXNvbHZlKF9jb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdHMgPSBoYW5kbGVyKF9jb21wb25lbnQsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoX3Jlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5pcXVlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnc3Vic2NyaXB0LWNoaWxkLWZpbHRlcl9leHByZXNzaW9uJzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcGFydGlhbCwgY291bnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNsaWNlIG91dCB0aGUgZXhwcmVzc2lvbiBmcm9tID8oZXhwcmVzc2lvbilcclxuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBjb21wb25lbnQuZXhwcmVzc2lvbi52YWx1ZS5zbGljZSgyLCAtMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXN0ID0gYWVzcHJpbS5wYXJzZShzcmMpLmJvZHlbMF0uZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIHZhciBwYXNzYWJsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKGFzdCwgeyAnQCc6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc2NlbmQocGFydGlhbCwgbnVsbCwgcGFzc2FibGUsIGNvdW50KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ3N1YnNjcmlwdC1kZXNjZW5kYW50LWZpbHRlcl9leHByZXNzaW9uJzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcGFydGlhbCwgY291bnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNsaWNlIG91dCB0aGUgZXhwcmVzc2lvbiBmcm9tID8oZXhwcmVzc2lvbilcclxuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBjb21wb25lbnQuZXhwcmVzc2lvbi52YWx1ZS5zbGljZSgyLCAtMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXN0ID0gYWVzcHJpbS5wYXJzZShzcmMpLmJvZHlbMF0uZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIHZhciBwYXNzYWJsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKGFzdCwgeyAnQCc6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYXZlcnNlKHBhcnRpYWwsIG51bGwsIHBhc3NhYmxlLCBjb3VudCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdzdWJzY3JpcHQtY2hpbGQtc2NyaXB0X2V4cHJlc3Npb24nOiBmdW5jdGlvbiAoY29tcG9uZW50LCBwYXJ0aWFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwID0gY29tcG9uZW50LmV4cHJlc3Npb24udmFsdWUuc2xpY2UoMSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2YWxfcmVjdXJzZShwYXJ0aWFsLCBleHAsICckW3t7dmFsdWV9fV0nKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ21lbWJlci1jaGlsZC1zY3JpcHRfZXhwcmVzc2lvbic6IGZ1bmN0aW9uIChjb21wb25lbnQsIHBhcnRpYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHAgPSBjb21wb25lbnQuZXhwcmVzc2lvbi52YWx1ZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbF9yZWN1cnNlKHBhcnRpYWwsIGV4cCwgJyQue3t2YWx1ZX19Jyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdtZW1iZXItZGVzY2VuZGFudC1zY3JpcHRfZXhwcmVzc2lvbic6IGZ1bmN0aW9uIChjb21wb25lbnQsIHBhcnRpYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHAgPSBjb21wb25lbnQuZXhwcmVzc2lvbi52YWx1ZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbF9yZWN1cnNlKHBhcnRpYWwsIGV4cCwgJyQuLnZhbHVlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgSGFuZGxlcnMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmF2ZXJzZSA9IHRyYXZlcnNlcih0cnVlKTtcclxuICAgICAgICB0aGlzLmRlc2NlbmQgPSB0cmF2ZXJzZXIoKTtcclxuICAgICAgICB0aGlzLl9mbnNbJ3N1YnNjcmlwdC1jaGlsZC1zdHJpbmdfbGl0ZXJhbCddID1cclxuICAgICAgICAgICAgdGhpcy5fZm5zWydtZW1iZXItY2hpbGQtaWRlbnRpZmllciddO1xyXG4gICAgICAgIHRoaXMuX2Zuc1snbWVtYmVyLWRlc2NlbmRhbnQtbnVtZXJpY19saXRlcmFsJ10gPVxyXG4gICAgICAgICAgICB0aGlzLl9mbnNbJ3N1YnNjcmlwdC1kZXNjZW5kYW50LXN0cmluZ19saXRlcmFsJ10gPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm5zWydtZW1iZXItZGVzY2VuZGFudC1pZGVudGlmaWVyJ107XHJcbiAgICB9O1xyXG4gICAgSGFuZGxlcnMucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IFtjb21wb25lbnQub3BlcmF0aW9uLCBjb21wb25lbnQuc2NvcGUsIGNvbXBvbmVudC5leHByZXNzaW9uLnR5cGVdLmpvaW4oJy0nKTtcclxuICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5fZm5zW2tleV07XHJcbiAgICAgICAgaWYgKCFtZXRob2QpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IHJlc29sdmUga2V5OiBcIiArIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEhhbmRsZXJzLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChrZXksIGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIShoYW5kbGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImhhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9mbnNba2V5XSA9IGhhbmRsZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhhbmRsZXJzO1xyXG59KCkpO1xyXG5leHBvcnQgeyBIYW5kbGVycyB9O1xyXG5mdW5jdGlvbiB1bmlxKGFycmF5LCBpdGVyYXRlZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIHNlZW4gPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheSA9PT0gbnVsbCB8fCBhcnJheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSwgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpKSA6IHZhbHVlO1xyXG4gICAgICAgIGlmICghc2Vlbi5pbmNsdWRlcyhjb21wdXRlZCkpIHtcclxuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFuZGxlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/handlers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONPath: () => (/* reexport safe */ _jsonpath__WEBPACK_IMPORTED_MODULE_0__.JSONPath)\n/* harmony export */ });\n/* harmony import */ var _jsonpath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsonpath */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/jsonpath.js\");\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2hpc3RsZXgvZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vaW5kZXguanM/MWNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2pzb25wYXRoJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/jsonpath.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/jsonpath.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONPath: () => (/* binding */ JSONPath)\n/* harmony export */ });\n/* harmony import */ var _handlers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handlers */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/handlers.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokens */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/tokens.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/parser.js\");\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/assert.js\");\n\r\n\r\n\r\n\r\nvar JSONPath = /** @class */ (function () {\r\n    function JSONPath() {\r\n    }\r\n    JSONPath.parse = function (string) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(typeof string === 'string', \"we need a path\");\r\n        return new _parser__WEBPACK_IMPORTED_MODULE_2__.Parser().parse(string);\r\n    };\r\n    JSONPath.parent = function (obj, string) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(obj instanceof Object, \"obj needs to be an object\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(string, \"we need a path\");\r\n        var node = this.nodes(obj, string)[0];\r\n        var key = node.path.pop(); /* jshint unused:false */\r\n        return this.value(obj, node.path);\r\n    };\r\n    JSONPath.apply = function (obj, string, fn) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(obj instanceof Object, \"obj needs to be an object\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(string, \"we need a path\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.equal(typeof fn, \"function\", \"fn needs to be function\");\r\n        var nodes = this.nodes(obj, string).sort(function (a, b) {\r\n            // sort nodes so we apply from the bottom up\r\n            return b.path.length - a.path.length;\r\n        });\r\n        nodes.forEach(function (node) {\r\n            var key = node.path.pop();\r\n            var parent = this.value(obj, this.stringify(node.path));\r\n            var val = node.value = fn.call(obj, parent[key]);\r\n            parent[key] = val;\r\n        }, this);\r\n        return nodes;\r\n    };\r\n    JSONPath.value = function (obj, path, value) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(obj instanceof Object, \"obj needs to be an object\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(path, \"we need a path\");\r\n        if (value !== undefined) {\r\n            var node = this.nodes(obj, path).shift();\r\n            if (!node)\r\n                return this._vivify(obj, path, value);\r\n            var key = node.path.slice(-1).shift();\r\n            var parent = this.parent(obj, this.stringify(node.path));\r\n            parent[key] = value;\r\n        }\r\n        return this.query(obj, this.stringify(path), 1).shift();\r\n    };\r\n    JSONPath._vivify = function (obj, string, value) {\r\n        var self = this;\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(obj instanceof Object, \"obj needs to be an object\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(string, \"we need a path\");\r\n        var path = new _parser__WEBPACK_IMPORTED_MODULE_2__.Parser().parse(string)\r\n            .map(function (component) { return component.expression.value; });\r\n        var setValue = function (path, value) {\r\n            var key = path.pop();\r\n            var node = self.value(obj, path);\r\n            if (!node) {\r\n                setValue(path.concat(), typeof key === 'string' ? {} : []);\r\n                node = self.value(obj, path);\r\n            }\r\n            node[key] = value;\r\n        };\r\n        setValue(path, value);\r\n        return this.query(obj, string)[0];\r\n    };\r\n    JSONPath.query = function (obj, string, count) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(obj instanceof Object, \"obj needs to be an object\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(typeof string === 'string', \"we need a path\");\r\n        var results = this.nodes(obj, string, count)\r\n            .map(function (r) { return r.value; });\r\n        return results;\r\n    };\r\n    JSONPath.paths = function (obj, string, count) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(obj instanceof Object, \"obj needs to be an object\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(string, \"we need a path\");\r\n        var results = this.nodes(obj, string, count)\r\n            .map(function (r) { return r.path; });\r\n        return results;\r\n    };\r\n    JSONPath.nodes = function (obj, string, count) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(obj instanceof Object, \"obj needs to be an object\");\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(string, \"we need a path\");\r\n        if (count === 0)\r\n            return [];\r\n        var path = new _parser__WEBPACK_IMPORTED_MODULE_2__.Parser().parse(string);\r\n        var handlers = new _handlers__WEBPACK_IMPORTED_MODULE_0__.Handlers();\r\n        var partials = [{ path: ['$'], value: obj }];\r\n        var matches = [];\r\n        if (path.length && path[0].expression.type == 'root')\r\n            path.shift();\r\n        if (!path.length)\r\n            return partials;\r\n        path.forEach(function (component, index) {\r\n            if (matches.length >= count)\r\n                return;\r\n            var handler = handlers.resolve(component);\r\n            var _partials = [];\r\n            partials.forEach(function (p) {\r\n                if (matches.length >= count)\r\n                    return;\r\n                var results = handler(component, p, count);\r\n                if (index == path.length - 1) {\r\n                    // if we're through the components we're done\r\n                    matches = matches.concat(results || []);\r\n                }\r\n                else {\r\n                    // otherwise accumulate and carry on through\r\n                    _partials = _partials.concat(results || []);\r\n                }\r\n            });\r\n            partials = _partials;\r\n        });\r\n        return count ? matches.slice(0, count) : matches;\r\n    };\r\n    JSONPath.stringify = function (path) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(path, \"we need a path\");\r\n        var string = '$';\r\n        var templates = {\r\n            'descendant-member': '..{{value}}',\r\n            'child-member': '.{{value}}',\r\n            'descendant-subscript': '..[{{value}}]',\r\n            'child-subscript': '[{{value}}]'\r\n        };\r\n        path = this._normalize(path);\r\n        path.forEach(function (component) {\r\n            if (component.expression.type == 'root')\r\n                return;\r\n            var key = [component.scope, component.operation].join('-');\r\n            var template = templates[key];\r\n            var value;\r\n            if (component.expression.type == 'string_literal') {\r\n                value = JSON.stringify(component.expression.value);\r\n            }\r\n            else {\r\n                value = component.expression.value;\r\n            }\r\n            if (!template)\r\n                throw new Error(\"couldn't find template \" + key);\r\n            string += template.replace(/{{value}}/, value);\r\n        });\r\n        return string;\r\n    };\r\n    JSONPath._normalize = function (path) {\r\n        _assert__WEBPACK_IMPORTED_MODULE_3__.assert.ok(path, \"we need a path\");\r\n        if (typeof path == \"string\") {\r\n            return new _parser__WEBPACK_IMPORTED_MODULE_2__.Parser().parse(path);\r\n        }\r\n        else if (Array.isArray(path) && typeof path[0] == \"string\") {\r\n            var _path = [{ expression: { type: \"root\", value: \"$\" } }];\r\n            path.forEach(function (component, index) {\r\n                if (component == '$' && index === 0)\r\n                    return;\r\n                if (typeof component == \"string\" && component.match(\"^\" + _tokens__WEBPACK_IMPORTED_MODULE_1__.TOKENS.identifier + \"$\")) {\r\n                    _path.push({\r\n                        operation: 'member',\r\n                        scope: 'child',\r\n                        expression: { value: component, type: 'identifier' }\r\n                    });\r\n                }\r\n                else {\r\n                    var type = typeof component == \"number\" ?\r\n                        'numeric_literal' : 'string_literal';\r\n                    _path.push({\r\n                        operation: 'subscript',\r\n                        scope: 'child',\r\n                        expression: { value: component, type: type }\r\n                    });\r\n                }\r\n            });\r\n            return _path;\r\n        }\r\n        else if (Array.isArray(path) && typeof path[0] == \"object\") {\r\n            return path;\r\n        }\r\n        throw new Error(\"couldn't understand path \" + path);\r\n    };\r\n    return JSONPath;\r\n}());\r\n\r\n//# sourceMappingURL=jsonpath.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vanNvbnBhdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0M7QUFDSjtBQUNBO0FBQ0E7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJDQUFNO0FBQ2QsbUJBQW1CLDJDQUFNO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRLDJDQUFNO0FBQ2QsUUFBUSwyQ0FBTTtBQUNkO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQU07QUFDZCxRQUFRLDJDQUFNO0FBQ2QsUUFBUSwyQ0FBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQU07QUFDZCxRQUFRLDJDQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkLFFBQVEsMkNBQU07QUFDZCx1QkFBdUIsMkNBQU07QUFDN0Isd0NBQXdDLG9DQUFvQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkLFFBQVEsMkNBQU07QUFDZDtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkLFFBQVEsMkNBQU07QUFDZDtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkLFFBQVEsMkNBQU07QUFDZDtBQUNBO0FBQ0EsdUJBQXVCLDJDQUFNO0FBQzdCLDJCQUEyQiwrQ0FBUTtBQUNuQywwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQU07QUFDZDtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0MsZ0NBQWdDLE9BQU87QUFDdkMsMENBQTBDLE9BQU87QUFDakQsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkO0FBQ0EsdUJBQXVCLDJDQUFNO0FBQzdCO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYyw0QkFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDJDQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHdoaXN0bGV4L2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bhc3Ryb25hdXRsYWJzL2pzb25wYXRoL2Rpc3QuZXNtL2pzb25wYXRoLmpzPzIwYjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFuZGxlcnMgfSBmcm9tIFwiLi9oYW5kbGVyc1wiO1xyXG5pbXBvcnQgeyBUT0tFTlMgfSBmcm9tICcuL3Rva2Vucyc7XHJcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gJy4vcGFyc2VyJztcclxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi9hc3NlcnQnO1xyXG52YXIgSlNPTlBhdGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBKU09OUGF0aCgpIHtcclxuICAgIH1cclxuICAgIEpTT05QYXRoLnBhcnNlID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIGFzc2VydC5vayh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJywgXCJ3ZSBuZWVkIGEgcGF0aFwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcigpLnBhcnNlKHN0cmluZyk7XHJcbiAgICB9O1xyXG4gICAgSlNPTlBhdGgucGFyZW50ID0gZnVuY3Rpb24gKG9iaiwgc3RyaW5nKSB7XHJcbiAgICAgICAgYXNzZXJ0Lm9rKG9iaiBpbnN0YW5jZW9mIE9iamVjdCwgXCJvYmogbmVlZHMgdG8gYmUgYW4gb2JqZWN0XCIpO1xyXG4gICAgICAgIGFzc2VydC5vayhzdHJpbmcsIFwid2UgbmVlZCBhIHBhdGhcIik7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzKG9iaiwgc3RyaW5nKVswXTtcclxuICAgICAgICB2YXIga2V5ID0gbm9kZS5wYXRoLnBvcCgpOyAvKiBqc2hpbnQgdW51c2VkOmZhbHNlICovXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUob2JqLCBub2RlLnBhdGgpO1xyXG4gICAgfTtcclxuICAgIEpTT05QYXRoLmFwcGx5ID0gZnVuY3Rpb24gKG9iaiwgc3RyaW5nLCBmbikge1xyXG4gICAgICAgIGFzc2VydC5vayhvYmogaW5zdGFuY2VvZiBPYmplY3QsIFwib2JqIG5lZWRzIHRvIGJlIGFuIG9iamVjdFwiKTtcclxuICAgICAgICBhc3NlcnQub2soc3RyaW5nLCBcIndlIG5lZWQgYSBwYXRoXCIpO1xyXG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgZm4sIFwiZnVuY3Rpb25cIiwgXCJmbiBuZWVkcyB0byBiZSBmdW5jdGlvblwiKTtcclxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKG9iaiwgc3RyaW5nKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIC8vIHNvcnQgbm9kZXMgc28gd2UgYXBwbHkgZnJvbSB0aGUgYm90dG9tIHVwXHJcbiAgICAgICAgICAgIHJldHVybiBiLnBhdGgubGVuZ3RoIC0gYS5wYXRoLmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBub2RlLnBhdGgucG9wKCk7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnZhbHVlKG9iaiwgdGhpcy5zdHJpbmdpZnkobm9kZS5wYXRoKSk7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBub2RlLnZhbHVlID0gZm4uY2FsbChvYmosIHBhcmVudFtrZXldKTtcclxuICAgICAgICAgICAgcGFyZW50W2tleV0gPSB2YWw7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfTtcclxuICAgIEpTT05QYXRoLnZhbHVlID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsdWUpIHtcclxuICAgICAgICBhc3NlcnQub2sob2JqIGluc3RhbmNlb2YgT2JqZWN0LCBcIm9iaiBuZWVkcyB0byBiZSBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgYXNzZXJ0Lm9rKHBhdGgsIFwid2UgbmVlZCBhIHBhdGhcIik7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzKG9iaiwgcGF0aCkuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKCFub2RlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpdmlmeShvYmosIHBhdGgsIHZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIGtleSA9IG5vZGUucGF0aC5zbGljZSgtMSkuc2hpZnQoKTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KG9iaiwgdGhpcy5zdHJpbmdpZnkobm9kZS5wYXRoKSk7XHJcbiAgICAgICAgICAgIHBhcmVudFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KG9iaiwgdGhpcy5zdHJpbmdpZnkocGF0aCksIDEpLnNoaWZ0KCk7XHJcbiAgICB9O1xyXG4gICAgSlNPTlBhdGguX3ZpdmlmeSA9IGZ1bmN0aW9uIChvYmosIHN0cmluZywgdmFsdWUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgYXNzZXJ0Lm9rKG9iaiBpbnN0YW5jZW9mIE9iamVjdCwgXCJvYmogbmVlZHMgdG8gYmUgYW4gb2JqZWN0XCIpO1xyXG4gICAgICAgIGFzc2VydC5vayhzdHJpbmcsIFwid2UgbmVlZCBhIHBhdGhcIik7XHJcbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGFyc2VyKCkucGFyc2Uoc3RyaW5nKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb21wb25lbnQpIHsgcmV0dXJuIGNvbXBvbmVudC5leHByZXNzaW9uLnZhbHVlOyB9KTtcclxuICAgICAgICB2YXIgc2V0VmFsdWUgPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHBhdGgucG9wKCk7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gc2VsZi52YWx1ZShvYmosIHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHNldFZhbHVlKHBhdGguY29uY2F0KCksIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8ge30gOiBbXSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gc2VsZi52YWx1ZShvYmosIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2V0VmFsdWUocGF0aCwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KG9iaiwgc3RyaW5nKVswXTtcclxuICAgIH07XHJcbiAgICBKU09OUGF0aC5xdWVyeSA9IGZ1bmN0aW9uIChvYmosIHN0cmluZywgY291bnQpIHtcclxuICAgICAgICBhc3NlcnQub2sob2JqIGluc3RhbmNlb2YgT2JqZWN0LCBcIm9iaiBuZWVkcyB0byBiZSBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgYXNzZXJ0Lm9rKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnLCBcIndlIG5lZWQgYSBwYXRoXCIpO1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5ub2RlcyhvYmosIHN0cmluZywgY291bnQpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsdWU7IH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIEpTT05QYXRoLnBhdGhzID0gZnVuY3Rpb24gKG9iaiwgc3RyaW5nLCBjb3VudCkge1xyXG4gICAgICAgIGFzc2VydC5vayhvYmogaW5zdGFuY2VvZiBPYmplY3QsIFwib2JqIG5lZWRzIHRvIGJlIGFuIG9iamVjdFwiKTtcclxuICAgICAgICBhc3NlcnQub2soc3RyaW5nLCBcIndlIG5lZWQgYSBwYXRoXCIpO1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5ub2RlcyhvYmosIHN0cmluZywgY291bnQpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIucGF0aDsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9O1xyXG4gICAgSlNPTlBhdGgubm9kZXMgPSBmdW5jdGlvbiAob2JqLCBzdHJpbmcsIGNvdW50KSB7XHJcbiAgICAgICAgYXNzZXJ0Lm9rKG9iaiBpbnN0YW5jZW9mIE9iamVjdCwgXCJvYmogbmVlZHMgdG8gYmUgYW4gb2JqZWN0XCIpO1xyXG4gICAgICAgIGFzc2VydC5vayhzdHJpbmcsIFwid2UgbmVlZCBhIHBhdGhcIik7XHJcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGFyc2VyKCkucGFyc2Uoc3RyaW5nKTtcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSBuZXcgSGFuZGxlcnMoKTtcclxuICAgICAgICB2YXIgcGFydGlhbHMgPSBbeyBwYXRoOiBbJyQnXSwgdmFsdWU6IG9iaiB9XTtcclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAmJiBwYXRoWzBdLmV4cHJlc3Npb24udHlwZSA9PSAncm9vdCcpXHJcbiAgICAgICAgICAgIHBhdGguc2hpZnQoKTtcclxuICAgICAgICBpZiAoIXBhdGgubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbHM7XHJcbiAgICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+PSBjb3VudClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVycy5yZXNvbHZlKGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHZhciBfcGFydGlhbHMgPSBbXTtcclxuICAgICAgICAgICAgcGFydGlhbHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID49IGNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gaGFuZGxlcihjb21wb25lbnQsIHAsIGNvdW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSBwYXRoLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSB0aHJvdWdoIHRoZSBjb21wb25lbnRzIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5jb25jYXQocmVzdWx0cyB8fCBbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgYWNjdW11bGF0ZSBhbmQgY2Fycnkgb24gdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgICAgIF9wYXJ0aWFscyA9IF9wYXJ0aWFscy5jb25jYXQocmVzdWx0cyB8fCBbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwYXJ0aWFscyA9IF9wYXJ0aWFscztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY291bnQgPyBtYXRjaGVzLnNsaWNlKDAsIGNvdW50KSA6IG1hdGNoZXM7XHJcbiAgICB9O1xyXG4gICAgSlNPTlBhdGguc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICBhc3NlcnQub2socGF0aCwgXCJ3ZSBuZWVkIGEgcGF0aFwiKTtcclxuICAgICAgICB2YXIgc3RyaW5nID0gJyQnO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZXMgPSB7XHJcbiAgICAgICAgICAgICdkZXNjZW5kYW50LW1lbWJlcic6ICcuLnt7dmFsdWV9fScsXHJcbiAgICAgICAgICAgICdjaGlsZC1tZW1iZXInOiAnLnt7dmFsdWV9fScsXHJcbiAgICAgICAgICAgICdkZXNjZW5kYW50LXN1YnNjcmlwdCc6ICcuLlt7e3ZhbHVlfX1dJyxcclxuICAgICAgICAgICAgJ2NoaWxkLXN1YnNjcmlwdCc6ICdbe3t2YWx1ZX19XSdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhdGggPSB0aGlzLl9ub3JtYWxpemUocGF0aCk7XHJcbiAgICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5leHByZXNzaW9uLnR5cGUgPT0gJ3Jvb3QnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gW2NvbXBvbmVudC5zY29wZSwgY29tcG9uZW50Lm9wZXJhdGlvbl0uam9pbignLScpO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNba2V5XTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmV4cHJlc3Npb24udHlwZSA9PSAnc3RyaW5nX2xpdGVyYWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGNvbXBvbmVudC5leHByZXNzaW9uLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gY29tcG9uZW50LmV4cHJlc3Npb24udmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IGZpbmQgdGVtcGxhdGUgXCIgKyBrZXkpO1xyXG4gICAgICAgICAgICBzdHJpbmcgKz0gdGVtcGxhdGUucmVwbGFjZSgve3t2YWx1ZX19LywgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgSlNPTlBhdGguX25vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgYXNzZXJ0Lm9rKHBhdGgsIFwid2UgbmVlZCBhIHBhdGhcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoKS5wYXJzZShwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSAmJiB0eXBlb2YgcGF0aFswXSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHZhciBfcGF0aCA9IFt7IGV4cHJlc3Npb246IHsgdHlwZTogXCJyb290XCIsIHZhbHVlOiBcIiRcIiB9IH1dO1xyXG4gICAgICAgICAgICBwYXRoLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT0gJyQnICYmIGluZGV4ID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09IFwic3RyaW5nXCIgJiYgY29tcG9uZW50Lm1hdGNoKFwiXlwiICsgVE9LRU5TLmlkZW50aWZpZXIgKyBcIiRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfcGF0aC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAnbWVtYmVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGlsZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHsgdmFsdWU6IGNvbXBvbmVudCwgdHlwZTogJ2lkZW50aWZpZXInIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNvbXBvbmVudCA9PSBcIm51bWJlclwiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJ251bWVyaWNfbGl0ZXJhbCcgOiAnc3RyaW5nX2xpdGVyYWwnO1xyXG4gICAgICAgICAgICAgICAgICAgIF9wYXRoLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdzdWJzY3JpcHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ2NoaWxkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogeyB2YWx1ZTogY29tcG9uZW50LCB0eXBlOiB0eXBlIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSAmJiB0eXBlb2YgcGF0aFswXSA9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCB1bmRlcnN0YW5kIHBhdGggXCIgKyBwYXRoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSlNPTlBhdGg7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEpTT05QYXRoIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb25wYXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/jsonpath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/parser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/parser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* binding */ Parser)\n/* harmony export */ });\n/* harmony import */ var _generated_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../generated/parser */ \"(ssr)/./node_modules/@astronautlabs/jsonpath/generated/parser.js\");\n\r\n/**\r\n * @hidden\r\n * @internal\r\n */\r\nfunction Parser() {\r\n    var parser = new _generated_parser__WEBPACK_IMPORTED_MODULE_0__.Parser();\r\n    var _parseError = parser.parseError;\r\n    parser.yy.parseError = function () {\r\n        if (parser.yy.ast) {\r\n            parser.yy.ast.initialize();\r\n        }\r\n        _parseError.apply(parser, arguments);\r\n    };\r\n    return parser;\r\n}\r\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vcGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQkFBcUIscURBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2hpc3RsZXgvZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vcGFyc2VyLmpzPzcwYWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZ3BhcnNlciBmcm9tICcuLi9nZW5lcmF0ZWQvcGFyc2VyJztcclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gUGFyc2VyKCkge1xyXG4gICAgdmFyIHBhcnNlciA9IG5ldyBncGFyc2VyLlBhcnNlcigpO1xyXG4gICAgdmFyIF9wYXJzZUVycm9yID0gcGFyc2VyLnBhcnNlRXJyb3I7XHJcbiAgICBwYXJzZXIueXkucGFyc2VFcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocGFyc2VyLnl5LmFzdCkge1xyXG4gICAgICAgICAgICBwYXJzZXIueXkuYXN0LmluaXRpYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3BhcnNlRXJyb3IuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBwYXJzZXI7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/slice.js":
/*!****************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/slice.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   slice: () => (/* binding */ slice)\n/* harmony export */ });\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nfunction slice(arr, start, end, step) {\r\n    function integer(val) {\r\n        return String(val).match(/^[0-9]+$/) ? parseInt(val) :\r\n            Number.isFinite(val) ? parseInt(val, 10) : 0;\r\n    }\r\n    if (typeof start == 'string')\r\n        throw new Error(\"start cannot be a string\");\r\n    if (typeof end == 'string')\r\n        throw new Error(\"end cannot be a string\");\r\n    if (typeof step == 'string')\r\n        throw new Error(\"step cannot be a string\");\r\n    var len = arr.length;\r\n    if (step === 0)\r\n        throw new Error(\"step cannot be zero\");\r\n    step = step ? integer(step) : 1;\r\n    // normalize negative values\r\n    start = start < 0 ? len + start : start;\r\n    end = end < 0 ? len + end : end;\r\n    // default extents to extents\r\n    start = integer(start === 0 ? 0 : !start ? (step > 0 ? 0 : len - 1) : start);\r\n    end = integer(end === 0 ? 0 : !end ? (step > 0 ? len : -1) : end);\r\n    // clamp extents\r\n    start = step > 0 ? Math.max(0, start) : Math.min(len, start);\r\n    end = step > 0 ? Math.min(end, len) : Math.max(-1, end);\r\n    // return empty if extents are backwards\r\n    if (step > 0 && end <= start)\r\n        return [];\r\n    if (step < 0 && start <= end)\r\n        return [];\r\n    var result = [];\r\n    for (var i = start; i != end; i += step) {\r\n        if ((step < 0 && i <= end) || (step > 0 && i >= end))\r\n            break;\r\n        result.push(arr[i]);\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=slice.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vc2xpY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2hpc3RsZXgvZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vc2xpY2UuanM/NGUyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGludGVybmFsXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBlbmQsIHN0ZXApIHtcclxuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpLm1hdGNoKC9eWzAtOV0rJC8pID8gcGFyc2VJbnQodmFsKSA6XHJcbiAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh2YWwpID8gcGFyc2VJbnQodmFsLCAxMCkgOiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBjYW5ub3QgYmUgYSBzdHJpbmdcIik7XHJcbiAgICBpZiAodHlwZW9mIGVuZCA9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmQgY2Fubm90IGJlIGEgc3RyaW5nXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGVwID09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIGEgc3RyaW5nXCIpO1xyXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICBpZiAoc3RlcCA9PT0gMClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGVwIGNhbm5vdCBiZSB6ZXJvXCIpO1xyXG4gICAgc3RlcCA9IHN0ZXAgPyBpbnRlZ2VyKHN0ZXApIDogMTtcclxuICAgIC8vIG5vcm1hbGl6ZSBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgIHN0YXJ0ID0gc3RhcnQgPCAwID8gbGVuICsgc3RhcnQgOiBzdGFydDtcclxuICAgIGVuZCA9IGVuZCA8IDAgPyBsZW4gKyBlbmQgOiBlbmQ7XHJcbiAgICAvLyBkZWZhdWx0IGV4dGVudHMgdG8gZXh0ZW50c1xyXG4gICAgc3RhcnQgPSBpbnRlZ2VyKHN0YXJ0ID09PSAwID8gMCA6ICFzdGFydCA/IChzdGVwID4gMCA/IDAgOiBsZW4gLSAxKSA6IHN0YXJ0KTtcclxuICAgIGVuZCA9IGludGVnZXIoZW5kID09PSAwID8gMCA6ICFlbmQgPyAoc3RlcCA+IDAgPyBsZW4gOiAtMSkgOiBlbmQpO1xyXG4gICAgLy8gY2xhbXAgZXh0ZW50c1xyXG4gICAgc3RhcnQgPSBzdGVwID4gMCA/IE1hdGgubWF4KDAsIHN0YXJ0KSA6IE1hdGgubWluKGxlbiwgc3RhcnQpO1xyXG4gICAgZW5kID0gc3RlcCA+IDAgPyBNYXRoLm1pbihlbmQsIGxlbikgOiBNYXRoLm1heCgtMSwgZW5kKTtcclxuICAgIC8vIHJldHVybiBlbXB0eSBpZiBleHRlbnRzIGFyZSBiYWNrd2FyZHNcclxuICAgIGlmIChzdGVwID4gMCAmJiBlbmQgPD0gc3RhcnQpXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgaWYgKHN0ZXAgPCAwICYmIHN0YXJ0IDw9IGVuZClcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgIT0gZW5kOyBpICs9IHN0ZXApIHtcclxuICAgICAgICBpZiAoKHN0ZXAgPCAwICYmIGkgPD0gZW5kKSB8fCAoc3RlcCA+IDAgJiYgaSA+PSBlbmQpKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/slice.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/tokens.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/dist.esm/tokens.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TOKENS: () => (/* binding */ TOKENS)\n/* harmony export */ });\n/**\r\n * Defines the token types of JSONPath by regular expression.\r\n * @internal\r\n * @hidden\r\n */\r\nvar TOKENS = {\r\n    identifier: \"[a-zA-Z_]+[a-zA-Z0-9_]*\",\r\n    integer: \"-?(?:0|[1-9][0-9]*)\",\r\n    qq_string: \"\\\"(?:\\\\\\\\[\\\"bfnrt/\\\\\\\\]|\\\\\\\\u[a-fA-F0-9]{4}|[^\\\"\\\\\\\\])*\\\"\",\r\n    q_string: \"'(?:\\\\\\\\[\\'bfnrt/\\\\\\\\]|\\\\\\\\u[a-fA-F0-9]{4}|[^\\'\\\\\\\\])*'\"\r\n};\r\n//# sourceMappingURL=tokens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZGlzdC5lc20vdG9rZW5zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EseURBQXlELEVBQUU7QUFDM0QsdURBQXVELEVBQUU7QUFDekQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B3aGlzdGxleC9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AYXN0cm9uYXV0bGFicy9qc29ucGF0aC9kaXN0LmVzbS90b2tlbnMuanM/Y2EzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGVmaW5lcyB0aGUgdG9rZW4gdHlwZXMgb2YgSlNPTlBhdGggYnkgcmVndWxhciBleHByZXNzaW9uLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGhpZGRlblxyXG4gKi9cclxuZXhwb3J0IHZhciBUT0tFTlMgPSB7XHJcbiAgICBpZGVudGlmaWVyOiBcIlthLXpBLVpfXStbYS16QS1aMC05X10qXCIsXHJcbiAgICBpbnRlZ2VyOiBcIi0/KD86MHxbMS05XVswLTldKilcIixcclxuICAgIHFxX3N0cmluZzogXCJcXFwiKD86XFxcXFxcXFxbXFxcImJmbnJ0L1xcXFxcXFxcXXxcXFxcXFxcXHVbYS1mQS1GMC05XXs0fXxbXlxcXCJcXFxcXFxcXF0pKlxcXCJcIixcclxuICAgIHFfc3RyaW5nOiBcIicoPzpcXFxcXFxcXFtcXCdiZm5ydC9cXFxcXFxcXF18XFxcXFxcXFx1W2EtZkEtRjAtOV17NH18W15cXCdcXFxcXFxcXF0pKidcIlxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/dist.esm/tokens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@astronautlabs/jsonpath/generated/parser.js":
/*!******************************************************************!*\
  !*** ./node_modules/@astronautlabs/jsonpath/generated/parser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,5],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[1,9],$V5=[1,18],$V6=[1,19],$V7=[1,20],$V8=[1,12,14,22],$V9=[1,29],$Va=[1,30],$Vb=[1,33],$Vc=[1,35],$Vd=[1,31],$Ve=[1,36],$Vf=[1,37],$Vg=[24,28];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"JSON_PATH\":3,\"DOLLAR\":4,\"PATH_COMPONENTS\":5,\"LEADING_CHILD_MEMBER_EXPRESSION\":6,\"PATH_COMPONENT\":7,\"MEMBER_COMPONENT\":8,\"SUBSCRIPT_COMPONENT\":9,\"CHILD_MEMBER_COMPONENT\":10,\"DESCENDANT_MEMBER_COMPONENT\":11,\"DOT\":12,\"MEMBER_EXPRESSION\":13,\"DOT_DOT\":14,\"STAR\":15,\"IDENTIFIER\":16,\"SCRIPT_EXPRESSION\":17,\"INTEGER\":18,\"END\":19,\"CHILD_SUBSCRIPT_COMPONENT\":20,\"DESCENDANT_SUBSCRIPT_COMPONENT\":21,\"[\":22,\"SUBSCRIPT\":23,\"]\":24,\"SUBSCRIPT_EXPRESSION\":25,\"SUBSCRIPT_EXPRESSION_LIST\":26,\"SUBSCRIPT_EXPRESSION_LISTABLE\":27,\",\":28,\"STRING_LITERAL\":29,\"ARRAY_SLICE\":30,\"FILTER_EXPRESSION\":31,\"QQ_STRING\":32,\"Q_STRING\":33,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",4:\"DOLLAR\",12:\"DOT\",14:\"DOT_DOT\",15:\"STAR\",16:\"IDENTIFIER\",17:\"SCRIPT_EXPRESSION\",18:\"INTEGER\",19:\"END\",22:\"[\",24:\"]\",28:\",\",30:\"ARRAY_SLICE\",31:\"FILTER_EXPRESSION\",32:\"QQ_STRING\",33:\"Q_STRING\"},\nproductions_: [0,[3,1],[3,2],[3,1],[3,2],[5,1],[5,2],[7,1],[7,1],[8,1],[8,1],[10,2],[6,1],[11,2],[13,1],[13,1],[13,1],[13,1],[13,1],[9,1],[9,1],[20,3],[21,4],[23,1],[23,1],[26,1],[26,3],[27,1],[27,1],[27,1],[25,1],[25,1],[25,1],[29,1],[29,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\nif (!yy.ast) {\r\n    yy.ast = _ast;\r\n    _ast.initialize();\r\n}\r\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\nyy.ast.set({ expression: { type: \"root\", value: $$[$0] } }); yy.ast.unshift(); return yy.ast.yield()\nbreak;\ncase 2:\nyy.ast.set({ expression: { type: \"root\", value: $$[$0-1] } }); yy.ast.unshift(); return yy.ast.yield()\nbreak;\ncase 3:\nyy.ast.unshift(); return yy.ast.yield()\nbreak;\ncase 4:\nyy.ast.set({ operation: \"member\", scope: \"child\", expression: { type: \"identifier\", value: $$[$0-1] }}); yy.ast.unshift(); return yy.ast.yield()\nbreak;\ncase 5: case 6: case 11: case 13: case 18: case 21: case 22: case 23:\n\nbreak;\ncase 7:\nyy.ast.set({ operation: \"member\" }); yy.ast.push()\nbreak;\ncase 8:\nyy.ast.set({ operation: \"subscript\" }); yy.ast.push() \nbreak;\ncase 9: case 19:\nyy.ast.set({ scope: \"child\" })\nbreak;\ncase 10: case 20:\nyy.ast.set({ scope: \"descendant\" })\nbreak;\ncase 12:\nyy.ast.set({ scope: \"child\", operation: \"member\" })\nbreak;\ncase 14:\nyy.ast.set({ expression: { type: \"wildcard\", value: $$[$0] } })\nbreak;\ncase 15:\nyy.ast.set({ expression: { type: \"identifier\", value: $$[$0] } })\nbreak;\ncase 16:\nyy.ast.set({ expression: { type: \"script_expression\", value: $$[$0] } })\nbreak;\ncase 17:\nyy.ast.set({ expression: { type: \"numeric_literal\", value: parseInt($$[$0]) } })\nbreak;\ncase 24:\n$$[$0].length > 1? yy.ast.set({ expression: { type: \"union\", value: $$[$0] } }) : this.$ = $$[$0]\nbreak;\ncase 25:\nthis.$ = [$$[$0]]\nbreak;\ncase 26:\nthis.$ = $$[$0-2].concat($$[$0])\nbreak;\ncase 27:\nthis.$ = { expression: { type: \"numeric_literal\", value: parseInt($$[$0]) } }; yy.ast.set(this.$)\nbreak;\ncase 28:\nthis.$ = { expression: { type: \"string_literal\", value: $$[$0] } }; yy.ast.set(this.$)\nbreak;\ncase 29:\nthis.$ = { expression: { type: \"slice\", value: $$[$0] } }; yy.ast.set(this.$)\nbreak;\ncase 30:\nthis.$ = { expression: { type: \"wildcard\", value: $$[$0] } }; yy.ast.set(this.$)\nbreak;\ncase 31:\nthis.$ = { expression: { type: \"script_expression\", value: $$[$0] } }; yy.ast.set(this.$)\nbreak;\ncase 32:\nthis.$ = { expression: { type: \"filter_expression\", value: $$[$0] } }; yy.ast.set(this.$)\nbreak;\ncase 33: case 34:\nthis.$ = $$[$0]\nbreak;\n}\n},\ntable: [{3:1,4:[1,2],6:3,13:4,15:$V0,16:$V1,17:$V2,18:$V3,19:$V4},{1:[3]},{1:[2,1],5:10,7:11,8:12,9:13,10:14,11:15,12:$V5,14:$V6,20:16,21:17,22:$V7},{1:[2,3],5:21,7:11,8:12,9:13,10:14,11:15,12:$V5,14:$V6,20:16,21:17,22:$V7},o($V8,[2,12]),o($V8,[2,14]),o($V8,[2,15]),o($V8,[2,16]),o($V8,[2,17]),o($V8,[2,18]),{1:[2,2],7:22,8:12,9:13,10:14,11:15,12:$V5,14:$V6,20:16,21:17,22:$V7},o($V8,[2,5]),o($V8,[2,7]),o($V8,[2,8]),o($V8,[2,9]),o($V8,[2,10]),o($V8,[2,19]),o($V8,[2,20]),{13:23,15:$V0,16:$V1,17:$V2,18:$V3,19:$V4},{13:24,15:$V0,16:$V1,17:$V2,18:$V3,19:$V4,22:[1,25]},{15:$V9,17:$Va,18:$Vb,23:26,25:27,26:28,27:32,29:34,30:$Vc,31:$Vd,32:$Ve,33:$Vf},{1:[2,4],7:22,8:12,9:13,10:14,11:15,12:$V5,14:$V6,20:16,21:17,22:$V7},o($V8,[2,6]),o($V8,[2,11]),o($V8,[2,13]),{15:$V9,17:$Va,18:$Vb,23:38,25:27,26:28,27:32,29:34,30:$Vc,31:$Vd,32:$Ve,33:$Vf},{24:[1,39]},{24:[2,23]},{24:[2,24],28:[1,40]},{24:[2,30]},{24:[2,31]},{24:[2,32]},o($Vg,[2,25]),o($Vg,[2,27]),o($Vg,[2,28]),o($Vg,[2,29]),o($Vg,[2,33]),o($Vg,[2,34]),{24:[1,41]},o($V8,[2,21]),{18:$Vb,27:42,29:34,30:$Vc,32:$Ve,33:$Vf},o($V8,[2,22]),o($Vg,[2,26])],\ndefaultActions: {27:[2,23],29:[2,30],30:[2,31],31:[2,32]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\nvar _ast = {\r\n\r\n  initialize: function() {\r\n    this._nodes = [];\r\n    this._node = {};\r\n    this._stash = [];\r\n  },\r\n\r\n  set: function(props) {\r\n    for (var k in props) this._node[k] = props[k];\r\n    return this._node;\r\n  },\r\n\r\n  node: function(obj) {\r\n    if (arguments.length) this._node = obj;\r\n    return this._node;\r\n  },\r\n\r\n  push: function() {\r\n    this._nodes.push(this._node);\r\n    this._node = {};\r\n  },\r\n\r\n  unshift: function() {\r\n    this._nodes.unshift(this._node);\r\n    this._node = {};\r\n  },\r\n\r\n  yield: function() {\r\n    var _nodes = this._nodes;\r\n    this.initialize();\r\n    return _nodes;\r\n  }\r\n};\r\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 4\nbreak;\ncase 1:return 14\nbreak;\ncase 2:return 12\nbreak;\ncase 3:return 15\nbreak;\ncase 4:return 16\nbreak;\ncase 5:return 22\nbreak;\ncase 6:return 24\nbreak;\ncase 7:return 28\nbreak;\ncase 8:return 30\nbreak;\ncase 9:return 18\nbreak;\ncase 10:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 32;\nbreak;\ncase 11:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 33;\nbreak;\ncase 12:return 17\nbreak;\ncase 13:return 31\nbreak;\n}\n},\nrules: [/^(?:\\$)/,/^(?:\\.\\.)/,/^(?:\\.)/,/^(?:\\*)/,/^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/,/^(?:\\[)/,/^(?:\\])/,/^(?:,)/,/^(?:((-?(?:0|[1-9][0-9]*)))?\\:((-?(?:0|[1-9][0-9]*)))?(\\:((-?(?:0|[1-9][0-9]*)))?)?)/,/^(?:(-?(?:0|[1-9][0-9]*)))/,/^(?:\"(?:\\\\[\"bfnrt\\/\\\\]|\\\\u[a-fA-F0-9]{4}|[^\"\\\\])*\")/,/^(?:'(?:\\\\['bfnrt\\/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*')/,/^(?:\\(.+?\\)(?=\\]))/,/^(?:\\?\\(.+?\\)(?=\\]))/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (true) {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZ2VuZXJhdGVkL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9KQUFvSjtBQUNwSixTQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxZQUFZLElBQUksV0FBVyxTQUFTO0FBQ3ZFLGNBQWMsNEJBQTRCO0FBQzFDLE1BQU07QUFDTixXQUFXLDZuQkFBNm5CO0FBQ3hvQixhQUFhLDRNQUE0TTtBQUN6TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWMsK0JBQStCLEdBQUcsa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQSxhQUFhLGNBQWMsaUNBQWlDLEdBQUcsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWEsbURBQW1ELHNDQUFzQyxHQUFHLGtCQUFrQjtBQUMzSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQixHQUFHO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QixHQUFHO0FBQ3hDO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhLGNBQWMsbUNBQW1DO0FBQzlEO0FBQ0E7QUFDQSxhQUFhLGNBQWMscUNBQXFDO0FBQ2hFO0FBQ0E7QUFDQSxhQUFhLGNBQWMsNENBQTRDO0FBQ3ZFO0FBQ0E7QUFDQSxhQUFhLGNBQWMsb0RBQW9EO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYyxnQ0FBZ0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYyxzREFBc0Q7QUFDL0U7QUFDQTtBQUNBLFdBQVcsY0FBYywyQ0FBMkM7QUFDcEU7QUFDQTtBQUNBLFdBQVcsY0FBYyxrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBLFdBQVcsY0FBYyxxQ0FBcUM7QUFDOUQ7QUFDQTtBQUNBLFdBQVcsY0FBYyw4Q0FBOEM7QUFDdkU7QUFDQTtBQUNBLFdBQVcsY0FBYyw4Q0FBOEM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTLHdEQUF3RCxFQUFFLE1BQU0sRUFBRSx5RUFBeUUsRUFBRSx5RUFBeUUsc0ZBQXNGLG9FQUFvRSxnR0FBZ0cseUNBQXlDLEVBQUUsbURBQW1ELEVBQUUsK0VBQStFLEVBQUUsb0VBQW9FLDJDQUEyQywrRUFBK0UsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLG9CQUFvQixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxzRkFBc0YsVUFBVSxnQkFBZ0Isd0NBQXdDO0FBQ2xqQyxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtDQUFrQztBQUNsQyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseVFBQXlRLEVBQUUsb0RBQW9ELEVBQUU7QUFDalUsYUFBYSxXQUFXO0FBQ3hCLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLENBQUM7OztBQUdELElBQUksSUFBZ0U7QUFDcEUsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhLGlCQUFpQjs7QUFFOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2hpc3RsZXgvZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGFzdHJvbmF1dGxhYnMvanNvbnBhdGgvZ2VuZXJhdGVkL3BhcnNlci5qcz8zMzhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC40LjE4ICovXG4vKlxuICBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblxuICBQYXJzZXI6IHtcbiAgICB5eToge31cbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGU6IHtcbiAgICB5eToge30sXG4gICAgdHJhY2U6IGZ1bmN0aW9uKCksXG4gICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LFxuICAgIHByb2R1Y3Rpb25zXzogWy4uLl0sXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCksXG4gICAgdGFibGU6IFsuLi5dLFxuICAgIGRlZmF1bHRBY3Rpb25zOiB7Li4ufSxcbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksXG5cbiAgICBsZXhlcjoge1xuICAgICAgICBFT0Y6IDEsXG4gICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCksXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAgICAgICAgbW9yZTogZnVuY3Rpb24oKSxcbiAgICAgICAgbGVzczogZnVuY3Rpb24obiksXG4gICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCksXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxleDogZnVuY3Rpb24oKSxcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gICAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJhbmdlczogYm9vbGVhbiAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlcilcbiAgICAgICAgICAgIGZsZXg6IGJvb2xlYW4gICAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZCBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaClcbiAgICAgICAgICAgIGJhY2t0cmFja19sZXhlcjogYm9vbGVhbiAgKG9wdGlvbmFsOiB0cnVlID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBlYWNoIG1hdGNoaW5nIHJlZ2V4IHRoZSBhY3Rpb24gY29kZSBpcyBpbnZva2VkOyB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlKVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSxcbiAgICAgICAgcnVsZXM6IFsuLi5dLFxuICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAgICB9XG4gIH1cblxuXG4gIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAgICBmaXJzdF9saW5lOiBuLFxuICAgIGxhc3RfbGluZTogbixcbiAgICBmaXJzdF9jb2x1bW46IG4sXG4gICAgbGFzdF9jb2x1bW46IG4sXG4gICAgcmFuZ2U6IFtzdGFydF9udW1iZXIsIGVuZF9udW1iZXJdICAgICAgICh3aGVyZSB0aGUgbnVtYmVycyBhcmUgaW5kZXhlcyBpbnRvIHRoZSBpbnB1dCBzdHJpbmcsIHJlZ3VsYXIgemVyby1iYXNlZClcbiAgfVxuXG5cbiAgdGhlIHBhcnNlRXJyb3IgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgYW5kIHBhcnNlciBlcnJvcnM6IHtcbiAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gIH1cbiAgd2hpbGUgcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgbWVtYmVycywgaS5lLiBwYXJzZXIgZXJyb3JzIGRlbGl2ZXIgYSBzdXBlcnNldCBvZiBhdHRyaWJ1dGVzOiB7XG4gICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gICAgZXhwZWN0ZWQ6ICAgIChzdHJpbmcgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucylcbiAgICByZWNvdmVyYWJsZTogKGJvb2xlYW46IFRSVUUgd2hlbiB0aGUgcGFyc2VyIGhhcyBhIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlIGZvciB0aGlzIHBhcnRpY3VsYXIgZXJyb3IpXG4gIH1cbiovXG52YXIgcGFyc2VyID0gKGZ1bmN0aW9uKCl7XG52YXIgbz1mdW5jdGlvbihrLHYsbyxsKXtmb3Iobz1vfHx7fSxsPWsubGVuZ3RoO2wtLTtvW2tbbF1dPXYpO3JldHVybiBvfSwkVjA9WzEsNV0sJFYxPVsxLDZdLCRWMj1bMSw3XSwkVjM9WzEsOF0sJFY0PVsxLDldLCRWNT1bMSwxOF0sJFY2PVsxLDE5XSwkVjc9WzEsMjBdLCRWOD1bMSwxMiwxNCwyMl0sJFY5PVsxLDI5XSwkVmE9WzEsMzBdLCRWYj1bMSwzM10sJFZjPVsxLDM1XSwkVmQ9WzEsMzFdLCRWZT1bMSwzNl0sJFZmPVsxLDM3XSwkVmc9WzI0LDI4XTtcbnZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlICgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJKU09OX1BBVEhcIjozLFwiRE9MTEFSXCI6NCxcIlBBVEhfQ09NUE9ORU5UU1wiOjUsXCJMRUFESU5HX0NISUxEX01FTUJFUl9FWFBSRVNTSU9OXCI6NixcIlBBVEhfQ09NUE9ORU5UXCI6NyxcIk1FTUJFUl9DT01QT05FTlRcIjo4LFwiU1VCU0NSSVBUX0NPTVBPTkVOVFwiOjksXCJDSElMRF9NRU1CRVJfQ09NUE9ORU5UXCI6MTAsXCJERVNDRU5EQU5UX01FTUJFUl9DT01QT05FTlRcIjoxMSxcIkRPVFwiOjEyLFwiTUVNQkVSX0VYUFJFU1NJT05cIjoxMyxcIkRPVF9ET1RcIjoxNCxcIlNUQVJcIjoxNSxcIklERU5USUZJRVJcIjoxNixcIlNDUklQVF9FWFBSRVNTSU9OXCI6MTcsXCJJTlRFR0VSXCI6MTgsXCJFTkRcIjoxOSxcIkNISUxEX1NVQlNDUklQVF9DT01QT05FTlRcIjoyMCxcIkRFU0NFTkRBTlRfU1VCU0NSSVBUX0NPTVBPTkVOVFwiOjIxLFwiW1wiOjIyLFwiU1VCU0NSSVBUXCI6MjMsXCJdXCI6MjQsXCJTVUJTQ1JJUFRfRVhQUkVTU0lPTlwiOjI1LFwiU1VCU0NSSVBUX0VYUFJFU1NJT05fTElTVFwiOjI2LFwiU1VCU0NSSVBUX0VYUFJFU1NJT05fTElTVEFCTEVcIjoyNyxcIixcIjoyOCxcIlNUUklOR19MSVRFUkFMXCI6MjksXCJBUlJBWV9TTElDRVwiOjMwLFwiRklMVEVSX0VYUFJFU1NJT05cIjozMSxcIlFRX1NUUklOR1wiOjMyLFwiUV9TVFJJTkdcIjozMyxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDQ6XCJET0xMQVJcIiwxMjpcIkRPVFwiLDE0OlwiRE9UX0RPVFwiLDE1OlwiU1RBUlwiLDE2OlwiSURFTlRJRklFUlwiLDE3OlwiU0NSSVBUX0VYUFJFU1NJT05cIiwxODpcIklOVEVHRVJcIiwxOTpcIkVORFwiLDIyOlwiW1wiLDI0OlwiXVwiLDI4OlwiLFwiLDMwOlwiQVJSQVlfU0xJQ0VcIiwzMTpcIkZJTFRFUl9FWFBSRVNTSU9OXCIsMzI6XCJRUV9TVFJJTkdcIiwzMzpcIlFfU1RSSU5HXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywxXSxbMywyXSxbMywxXSxbMywyXSxbNSwxXSxbNSwyXSxbNywxXSxbNywxXSxbOCwxXSxbOCwxXSxbMTAsMl0sWzYsMV0sWzExLDJdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzksMV0sWzksMV0sWzIwLDNdLFsyMSw0XSxbMjMsMV0sWzIzLDFdLFsyNiwxXSxbMjYsM10sWzI3LDFdLFsyNywxXSxbMjcsMV0sWzI1LDFdLFsyNSwxXSxbMjUsMV0sWzI5LDFdLFsyOSwxXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5pZiAoIXl5LmFzdCkge1xyXG4gICAgeXkuYXN0ID0gX2FzdDtcclxuICAgIF9hc3QuaW5pdGlhbGl6ZSgpO1xyXG59XHJcblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOlxueXkuYXN0LnNldCh7IGV4cHJlc3Npb246IHsgdHlwZTogXCJyb290XCIsIHZhbHVlOiAkJFskMF0gfSB9KTsgeXkuYXN0LnVuc2hpZnQoKTsgcmV0dXJuIHl5LmFzdC55aWVsZCgpXG5icmVhaztcbmNhc2UgMjpcbnl5LmFzdC5zZXQoeyBleHByZXNzaW9uOiB7IHR5cGU6IFwicm9vdFwiLCB2YWx1ZTogJCRbJDAtMV0gfSB9KTsgeXkuYXN0LnVuc2hpZnQoKTsgcmV0dXJuIHl5LmFzdC55aWVsZCgpXG5icmVhaztcbmNhc2UgMzpcbnl5LmFzdC51bnNoaWZ0KCk7IHJldHVybiB5eS5hc3QueWllbGQoKVxuYnJlYWs7XG5jYXNlIDQ6XG55eS5hc3Quc2V0KHsgb3BlcmF0aW9uOiBcIm1lbWJlclwiLCBzY29wZTogXCJjaGlsZFwiLCBleHByZXNzaW9uOiB7IHR5cGU6IFwiaWRlbnRpZmllclwiLCB2YWx1ZTogJCRbJDAtMV0gfX0pOyB5eS5hc3QudW5zaGlmdCgpOyByZXR1cm4geXkuYXN0LnlpZWxkKClcbmJyZWFrO1xuY2FzZSA1OiBjYXNlIDY6IGNhc2UgMTE6IGNhc2UgMTM6IGNhc2UgMTg6IGNhc2UgMjE6IGNhc2UgMjI6IGNhc2UgMjM6XG5cbmJyZWFrO1xuY2FzZSA3OlxueXkuYXN0LnNldCh7IG9wZXJhdGlvbjogXCJtZW1iZXJcIiB9KTsgeXkuYXN0LnB1c2goKVxuYnJlYWs7XG5jYXNlIDg6XG55eS5hc3Quc2V0KHsgb3BlcmF0aW9uOiBcInN1YnNjcmlwdFwiIH0pOyB5eS5hc3QucHVzaCgpIFxuYnJlYWs7XG5jYXNlIDk6IGNhc2UgMTk6XG55eS5hc3Quc2V0KHsgc2NvcGU6IFwiY2hpbGRcIiB9KVxuYnJlYWs7XG5jYXNlIDEwOiBjYXNlIDIwOlxueXkuYXN0LnNldCh7IHNjb3BlOiBcImRlc2NlbmRhbnRcIiB9KVxuYnJlYWs7XG5jYXNlIDEyOlxueXkuYXN0LnNldCh7IHNjb3BlOiBcImNoaWxkXCIsIG9wZXJhdGlvbjogXCJtZW1iZXJcIiB9KVxuYnJlYWs7XG5jYXNlIDE0OlxueXkuYXN0LnNldCh7IGV4cHJlc3Npb246IHsgdHlwZTogXCJ3aWxkY2FyZFwiLCB2YWx1ZTogJCRbJDBdIH0gfSlcbmJyZWFrO1xuY2FzZSAxNTpcbnl5LmFzdC5zZXQoeyBleHByZXNzaW9uOiB7IHR5cGU6IFwiaWRlbnRpZmllclwiLCB2YWx1ZTogJCRbJDBdIH0gfSlcbmJyZWFrO1xuY2FzZSAxNjpcbnl5LmFzdC5zZXQoeyBleHByZXNzaW9uOiB7IHR5cGU6IFwic2NyaXB0X2V4cHJlc3Npb25cIiwgdmFsdWU6ICQkWyQwXSB9IH0pXG5icmVhaztcbmNhc2UgMTc6XG55eS5hc3Quc2V0KHsgZXhwcmVzc2lvbjogeyB0eXBlOiBcIm51bWVyaWNfbGl0ZXJhbFwiLCB2YWx1ZTogcGFyc2VJbnQoJCRbJDBdKSB9IH0pXG5icmVhaztcbmNhc2UgMjQ6XG4kJFskMF0ubGVuZ3RoID4gMT8geXkuYXN0LnNldCh7IGV4cHJlc3Npb246IHsgdHlwZTogXCJ1bmlvblwiLCB2YWx1ZTogJCRbJDBdIH0gfSkgOiB0aGlzLiQgPSAkJFskMF1cbmJyZWFrO1xuY2FzZSAyNTpcbnRoaXMuJCA9IFskJFskMF1dXG5icmVhaztcbmNhc2UgMjY6XG50aGlzLiQgPSAkJFskMC0yXS5jb25jYXQoJCRbJDBdKVxuYnJlYWs7XG5jYXNlIDI3OlxudGhpcy4kID0geyBleHByZXNzaW9uOiB7IHR5cGU6IFwibnVtZXJpY19saXRlcmFsXCIsIHZhbHVlOiBwYXJzZUludCgkJFskMF0pIH0gfTsgeXkuYXN0LnNldCh0aGlzLiQpXG5icmVhaztcbmNhc2UgMjg6XG50aGlzLiQgPSB7IGV4cHJlc3Npb246IHsgdHlwZTogXCJzdHJpbmdfbGl0ZXJhbFwiLCB2YWx1ZTogJCRbJDBdIH0gfTsgeXkuYXN0LnNldCh0aGlzLiQpXG5icmVhaztcbmNhc2UgMjk6XG50aGlzLiQgPSB7IGV4cHJlc3Npb246IHsgdHlwZTogXCJzbGljZVwiLCB2YWx1ZTogJCRbJDBdIH0gfTsgeXkuYXN0LnNldCh0aGlzLiQpXG5icmVhaztcbmNhc2UgMzA6XG50aGlzLiQgPSB7IGV4cHJlc3Npb246IHsgdHlwZTogXCJ3aWxkY2FyZFwiLCB2YWx1ZTogJCRbJDBdIH0gfTsgeXkuYXN0LnNldCh0aGlzLiQpXG5icmVhaztcbmNhc2UgMzE6XG50aGlzLiQgPSB7IGV4cHJlc3Npb246IHsgdHlwZTogXCJzY3JpcHRfZXhwcmVzc2lvblwiLCB2YWx1ZTogJCRbJDBdIH0gfTsgeXkuYXN0LnNldCh0aGlzLiQpXG5icmVhaztcbmNhc2UgMzI6XG50aGlzLiQgPSB7IGV4cHJlc3Npb246IHsgdHlwZTogXCJmaWx0ZXJfZXhwcmVzc2lvblwiLCB2YWx1ZTogJCRbJDBdIH0gfTsgeXkuYXN0LnNldCh0aGlzLiQpXG5icmVhaztcbmNhc2UgMzM6IGNhc2UgMzQ6XG50aGlzLiQgPSAkJFskMF1cbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezM6MSw0OlsxLDJdLDY6MywxMzo0LDE1OiRWMCwxNjokVjEsMTc6JFYyLDE4OiRWMywxOTokVjR9LHsxOlszXX0sezE6WzIsMV0sNToxMCw3OjExLDg6MTIsOToxMywxMDoxNCwxMToxNSwxMjokVjUsMTQ6JFY2LDIwOjE2LDIxOjE3LDIyOiRWN30sezE6WzIsM10sNToyMSw3OjExLDg6MTIsOToxMywxMDoxNCwxMToxNSwxMjokVjUsMTQ6JFY2LDIwOjE2LDIxOjE3LDIyOiRWN30sbygkVjgsWzIsMTJdKSxvKCRWOCxbMiwxNF0pLG8oJFY4LFsyLDE1XSksbygkVjgsWzIsMTZdKSxvKCRWOCxbMiwxN10pLG8oJFY4LFsyLDE4XSksezE6WzIsMl0sNzoyMiw4OjEyLDk6MTMsMTA6MTQsMTE6MTUsMTI6JFY1LDE0OiRWNiwyMDoxNiwyMToxNywyMjokVjd9LG8oJFY4LFsyLDVdKSxvKCRWOCxbMiw3XSksbygkVjgsWzIsOF0pLG8oJFY4LFsyLDldKSxvKCRWOCxbMiwxMF0pLG8oJFY4LFsyLDE5XSksbygkVjgsWzIsMjBdKSx7MTM6MjMsMTU6JFYwLDE2OiRWMSwxNzokVjIsMTg6JFYzLDE5OiRWNH0sezEzOjI0LDE1OiRWMCwxNjokVjEsMTc6JFYyLDE4OiRWMywxOTokVjQsMjI6WzEsMjVdfSx7MTU6JFY5LDE3OiRWYSwxODokVmIsMjM6MjYsMjU6MjcsMjY6MjgsMjc6MzIsMjk6MzQsMzA6JFZjLDMxOiRWZCwzMjokVmUsMzM6JFZmfSx7MTpbMiw0XSw3OjIyLDg6MTIsOToxMywxMDoxNCwxMToxNSwxMjokVjUsMTQ6JFY2LDIwOjE2LDIxOjE3LDIyOiRWN30sbygkVjgsWzIsNl0pLG8oJFY4LFsyLDExXSksbygkVjgsWzIsMTNdKSx7MTU6JFY5LDE3OiRWYSwxODokVmIsMjM6MzgsMjU6MjcsMjY6MjgsMjc6MzIsMjk6MzQsMzA6JFZjLDMxOiRWZCwzMjokVmUsMzM6JFZmfSx7MjQ6WzEsMzldfSx7MjQ6WzIsMjNdfSx7MjQ6WzIsMjRdLDI4OlsxLDQwXX0sezI0OlsyLDMwXX0sezI0OlsyLDMxXX0sezI0OlsyLDMyXX0sbygkVmcsWzIsMjVdKSxvKCRWZyxbMiwyN10pLG8oJFZnLFsyLDI4XSksbygkVmcsWzIsMjldKSxvKCRWZyxbMiwzM10pLG8oJFZnLFsyLDM0XSksezI0OlsxLDQxXX0sbygkVjgsWzIsMjFdKSx7MTg6JFZiLDI3OjQyLDI5OjM0LDMwOiRWYywzMjokVmUsMzM6JFZmfSxvKCRWOCxbMiwyMl0pLG8oJFZnLFsyLDI2XSldLFxuZGVmYXVsdEFjdGlvbnM6IHsyNzpbMiwyM10sMjk6WzIsMzBdLDMwOlsyLDMxXSwzMTpbMiwzMl19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvciAoc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICBlcnJvci5oYXNoID0gaGFzaDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHRzdGFjayA9IFtdLCB2c3RhY2sgPSBbbnVsbF0sIGxzdGFjayA9IFtdLCB0YWJsZSA9IHRoaXMudGFibGUsIHl5dGV4dCA9ICcnLCB5eWxpbmVubyA9IDAsIHl5bGVuZyA9IDAsIHJlY292ZXJpbmcgPSAwLCBURVJST1IgPSAyLCBFT0YgPSAxO1xuICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciBzaGFyZWRTdGF0ZSA9IHsgeXk6IHt9IH07XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLnl5KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy55eSwgaykpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5W2tdID0gdGhpcy55eVtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXhlci5zZXRJbnB1dChpbnB1dCwgc2hhcmVkU3RhdGUueXkpO1xuICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXI7XG4gICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGxleGVyLnl5bGxvYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsZXhlci55eWxsb2MgPSB7fTtcbiAgICB9XG4gICAgdmFyIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcbiAgICB2YXIgcmFuZ2VzID0gbGV4ZXIub3B0aW9ucyAmJiBsZXhlci5vcHRpb25zLnJhbmdlcztcbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykucGFyc2VFcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wU3RhY2sobikge1xuICAgICAgICBzdGFjay5sZW5ndGggPSBzdGFjay5sZW5ndGggLSAyICogbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgfVxuICAgIF90b2tlbl9zdGFjazpcbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9O1xuICAgIHZhciBzeW1ib2wsIHByZUVycm9yU3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCBhLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICd1bmRlZmluZWQnIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IFRFUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaCgnXFwnJyArIHRoaXMudGVybWluYWxzX1twXSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6XFxuJyArIGxleGVyLnNob3dQb3NpdGlvbigpICsgJ1xcbkV4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCBcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOiBVbmV4cGVjdGVkICcgKyAoc3ltYm9sID09IEVPRiA/ICdlbmQgb2YgaW5wdXQnIDogJ1xcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICB5eWxpbmVubyA9IGxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvdmVyaW5nLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW1xuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFtcbiAgICAgICAgICAgICAgICB5eXRleHQsXG4gICAgICAgICAgICAgICAgeXlsZW5nLFxuICAgICAgICAgICAgICAgIHl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LFxuICAgICAgICAgICAgICAgIGFjdGlvblsxXSxcbiAgICAgICAgICAgICAgICB2c3RhY2ssXG4gICAgICAgICAgICAgICAgbHN0YWNrXG4gICAgICAgICAgICBdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpO1xuICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufX07XG52YXIgX2FzdCA9IHtcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xyXG4gICAgdGhpcy5fbm9kZSA9IHt9O1xyXG4gICAgdGhpcy5fc3Rhc2ggPSBbXTtcclxuICB9LFxyXG5cclxuICBzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBrIGluIHByb3BzKSB0aGlzLl9ub2RlW2tdID0gcHJvcHNba107XHJcbiAgICByZXR1cm4gdGhpcy5fbm9kZTtcclxuICB9LFxyXG5cclxuICBub2RlOiBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB0aGlzLl9ub2RlID0gb2JqO1xyXG4gICAgcmV0dXJuIHRoaXMuX25vZGU7XHJcbiAgfSxcclxuXHJcbiAgcHVzaDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9ub2Rlcy5wdXNoKHRoaXMuX25vZGUpO1xyXG4gICAgdGhpcy5fbm9kZSA9IHt9O1xyXG4gIH0sXHJcblxyXG4gIHVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbm9kZXMudW5zaGlmdCh0aGlzLl9ub2RlKTtcclxuICAgIHRoaXMuX25vZGUgPSB7fTtcclxuICB9LFxyXG5cclxuICB5aWVsZDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgX25vZGVzID0gdGhpcy5fbm9kZXM7XHJcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIHJldHVybiBfbm9kZXM7XHJcbiAgfVxyXG59O1xyXG4vKiBnZW5lcmF0ZWQgYnkgamlzb24tbGV4IDAuMy40ICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBsZXhlciA9ICh7XG5cbkVPRjoxLFxuXG5wYXJzZUVycm9yOmZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuc2V0SW5wdXQ6ZnVuY3Rpb24gKGlucHV0LCB5eSkge1xuICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbi8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbnVucHV0OmZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlO1xuXG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMClcbiAgICAgICAgICAgICAgICAgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgc2lnbmFscyB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGUgbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxucmVqZWN0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5wYXN0SW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICB9LFxuXG4vLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbnRlc3RfbWF0Y2g6ZnVuY3Rpb24obWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGJhY2t1cDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5uZXh0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxubGV4OmZ1bmN0aW9uIGxleCAoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luIChjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMgKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW1wiSU5JVElBTFwiXS5ydWxlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGVcbnRvcFN0YXRlOmZ1bmN0aW9uIHRvcFN0YXRlIChuKSB7XG4gICAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIklOSVRJQUxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFsaWFzIGZvciBiZWdpbihjb25kaXRpb24pXG5wdXNoU3RhdGU6ZnVuY3Rpb24gcHVzaFN0YXRlIChjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG5zdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5vcHRpb25zOiB7fSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkge1xudmFyIFlZU1RBVEU9WVlfU1RBUlQ7XG5zd2l0Y2goJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xuY2FzZSAwOnJldHVybiA0XG5icmVhaztcbmNhc2UgMTpyZXR1cm4gMTRcbmJyZWFrO1xuY2FzZSAyOnJldHVybiAxMlxuYnJlYWs7XG5jYXNlIDM6cmV0dXJuIDE1XG5icmVhaztcbmNhc2UgNDpyZXR1cm4gMTZcbmJyZWFrO1xuY2FzZSA1OnJldHVybiAyMlxuYnJlYWs7XG5jYXNlIDY6cmV0dXJuIDI0XG5icmVhaztcbmNhc2UgNzpyZXR1cm4gMjhcbmJyZWFrO1xuY2FzZSA4OnJldHVybiAzMFxuYnJlYWs7XG5jYXNlIDk6cmV0dXJuIDE4XG5icmVhaztcbmNhc2UgMTA6eXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDEseXlfLnl5bGVuZy0yKTsgcmV0dXJuIDMyO1xuYnJlYWs7XG5jYXNlIDExOnl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigxLHl5Xy55eWxlbmctMik7IHJldHVybiAzMztcbmJyZWFrO1xuY2FzZSAxMjpyZXR1cm4gMTdcbmJyZWFrO1xuY2FzZSAxMzpyZXR1cm4gMzFcbmJyZWFrO1xufVxufSxcbnJ1bGVzOiBbL14oPzpcXCQpLywvXig/OlxcLlxcLikvLC9eKD86XFwuKS8sL14oPzpcXCopLywvXig/OlthLXpBLVpfXStbYS16QS1aMC05X10qKS8sL14oPzpcXFspLywvXig/OlxcXSkvLC9eKD86LCkvLC9eKD86KCgtPyg/OjB8WzEtOV1bMC05XSopKSk/XFw6KCgtPyg/OjB8WzEtOV1bMC05XSopKSk/KFxcOigoLT8oPzowfFsxLTldWzAtOV0qKSkpPyk/KS8sL14oPzooLT8oPzowfFsxLTldWzAtOV0qKSkpLywvXig/OlwiKD86XFxcXFtcImJmbnJ0XFwvXFxcXF18XFxcXHVbYS1mQS1GMC05XXs0fXxbXlwiXFxcXF0pKlwiKS8sL14oPzonKD86XFxcXFsnYmZucnRcXC9cXFxcXXxcXFxcdVthLWZBLUYwLTldezR9fFteJ1xcXFxdKSonKS8sL14oPzpcXCguKz9cXCkoPz1cXF0pKS8sL14oPzpcXD9cXCguKz9cXCkoPz1cXF0pKS9dLFxuY29uZGl0aW9uczoge1wiSU5JVElBTFwiOntcInJ1bGVzXCI6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX19XG59KTtcbnJldHVybiBsZXhlcjtcbn0pKCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTsgfTtcblxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@astronautlabs/jsonpath/generated/parser.js\n");

/***/ })

};
;