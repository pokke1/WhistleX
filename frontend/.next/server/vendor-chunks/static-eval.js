/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/static-eval";
exports.ids = ["vendor-chunks/static-eval"];
exports.modules = {

/***/ "(ssr)/./node_modules/static-eval/index.js":
/*!*******************************************!*\
  !*** ./node_modules/static-eval/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var unparse = (__webpack_require__(/*! escodegen */ \"(ssr)/./node_modules/escodegen/escodegen.js\").generate);\n\nmodule.exports = function (ast, vars) {\n    if (!vars) vars = {};\n    var FAIL = {};\n    \n    var result = (function walk (node, scopeVars) {\n        if (node.type === 'Literal') {\n            return node.value;\n        }\n        else if (node.type === 'UnaryExpression'){\n            var val = walk(node.argument)\n            if (node.operator === '+') return +val\n            if (node.operator === '-') return -val\n            if (node.operator === '~') return ~val\n            if (node.operator === '!') return !val\n            return FAIL\n        }\n        else if (node.type === 'ArrayExpression') {\n            var xs = [];\n            for (var i = 0, l = node.elements.length; i < l; i++) {\n                var x = walk(node.elements[i]);\n                if (x === FAIL) return FAIL;\n                xs.push(x);\n            }\n            return xs;\n        }\n        else if (node.type === 'ObjectExpression') {\n            var obj = {};\n            for (var i = 0; i < node.properties.length; i++) {\n                var prop = node.properties[i];\n                var value = prop.value === null\n                    ? prop.value\n                    : walk(prop.value)\n                ;\n                if (value === FAIL) return FAIL;\n                obj[prop.key.value || prop.key.name] = value;\n            }\n            return obj;\n        }\n        else if (node.type === 'BinaryExpression' ||\n                 node.type === 'LogicalExpression') {\n            var l = walk(node.left);\n            if (l === FAIL) return FAIL;\n            var r = walk(node.right);\n            if (r === FAIL) return FAIL;\n            \n            var op = node.operator;\n            if (op === '==') return l == r;\n            if (op === '===') return l === r;\n            if (op === '!=') return l != r;\n            if (op === '!==') return l !== r;\n            if (op === '+') return l + r;\n            if (op === '-') return l - r;\n            if (op === '*') return l * r;\n            if (op === '/') return l / r;\n            if (op === '%') return l % r;\n            if (op === '<') return l < r;\n            if (op === '<=') return l <= r;\n            if (op === '>') return l > r;\n            if (op === '>=') return l >= r;\n            if (op === '|') return l | r;\n            if (op === '&') return l & r;\n            if (op === '^') return l ^ r;\n            if (op === '&&') return l && r;\n            if (op === '||') return l || r;\n            \n            return FAIL;\n        }\n        else if (node.type === 'Identifier') {\n            if ({}.hasOwnProperty.call(vars, node.name)) {\n                return vars[node.name];\n            }\n            else return FAIL;\n        }\n        else if (node.type === 'ThisExpression') {\n            if ({}.hasOwnProperty.call(vars, 'this')) {\n                return vars['this'];\n            }\n            else return FAIL;\n        }\n        else if (node.type === 'CallExpression') {\n            var callee = walk(node.callee);\n            if (callee === FAIL) return FAIL;\n            if (typeof callee !== 'function') return FAIL;\n            \n            var ctx = node.callee.object ? walk(node.callee.object) : FAIL;\n            if (ctx === FAIL) ctx = null;\n\n            var args = [];\n            for (var i = 0, l = node.arguments.length; i < l; i++) {\n                var x = walk(node.arguments[i]);\n                if (x === FAIL) return FAIL;\n                args.push(x);\n            }\n            return callee.apply(ctx, args);\n        }\n        else if (node.type === 'MemberExpression') {\n            var obj = walk(node.object);\n            // do not allow access to methods on Function \n            if((obj === FAIL) || (typeof obj == 'function')){\n                return FAIL;\n            }\n            if (node.property.type === 'Identifier') {\n                return obj[node.property.name];\n            }\n            var prop = walk(node.property);\n            if (prop === FAIL) return FAIL;\n            return obj[prop];\n        }\n        else if (node.type === 'ConditionalExpression') {\n            var val = walk(node.test)\n            if (val === FAIL) return FAIL;\n            return val ? walk(node.consequent) : walk(node.alternate)\n        }\n        else if (node.type === 'ExpressionStatement') {\n            var val = walk(node.expression)\n            if (val === FAIL) return FAIL;\n            return val;\n        }\n        else if (node.type === 'ReturnStatement') {\n            return walk(node.argument)\n        }\n        else if (node.type === 'FunctionExpression') {\n            \n            var bodies = node.body.body;\n            \n            // Create a \"scope\" for our arguments\n            var oldVars = {};\n            Object.keys(vars).forEach(function(element){\n                oldVars[element] = vars[element];\n            })\n\n            for(var i=0; i<node.params.length; i++){\n                var key = node.params[i];\n                if(key.type == 'Identifier'){\n                  vars[key.name] = null;\n                }\n                else return FAIL;\n            }\n            for(var i in bodies){\n                if(walk(bodies[i]) === FAIL){\n                    return FAIL;\n                }\n            }\n            // restore the vars and scope after we walk\n            vars = oldVars;\n            \n            var keys = Object.keys(vars);\n            var vals = keys.map(function(key) {\n                return vars[key];\n            });\n            return Function(keys.join(', '), 'return ' + unparse(node)).apply(null, vals);\n        }\n        else if (node.type === 'TemplateLiteral') {\n            var str = '';\n            for (var i = 0; i < node.expressions.length; i++) {\n                str += walk(node.quasis[i]);\n                str += walk(node.expressions[i]);\n            }\n            str += walk(node.quasis[i]);\n            return str;\n        }\n        else if (node.type === 'TaggedTemplateExpression') {\n            var tag = walk(node.tag);\n            var quasi = node.quasi;\n            var strings = quasi.quasis.map(walk);\n            var values = quasi.expressions.map(walk);\n            return tag.apply(null, [strings].concat(values));\n        }\n        else if (node.type === 'TemplateElement') {\n            return node.value.cooked;\n        }\n        else return FAIL;\n    })(ast);\n    \n    return result === FAIL ? undefined : result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhdGljLWV2YWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyw4RkFBNkI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYix5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHdoaXN0bGV4L2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3N0YXRpYy1ldmFsL2luZGV4LmpzPzNjZmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHVucGFyc2UgPSByZXF1aXJlKCdlc2NvZGVnZW4nKS5nZW5lcmF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXN0LCB2YXJzKSB7XG4gICAgaWYgKCF2YXJzKSB2YXJzID0ge307XG4gICAgdmFyIEZBSUwgPSB7fTtcbiAgICBcbiAgICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uIHdhbGsgKG5vZGUsIHNjb3BlVmFycykge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ1VuYXJ5RXhwcmVzc2lvbicpe1xuICAgICAgICAgICAgdmFyIHZhbCA9IHdhbGsobm9kZS5hcmd1bWVudClcbiAgICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSAnKycpIHJldHVybiArdmFsXG4gICAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciA9PT0gJy0nKSByZXR1cm4gLXZhbFxuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09ICd+JykgcmV0dXJuIH52YWxcbiAgICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSAnIScpIHJldHVybiAhdmFsXG4gICAgICAgICAgICByZXR1cm4gRkFJTFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0FycmF5RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIHZhciB4cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gd2Fsayhub2RlLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gRkFJTCkgcmV0dXJuIEZBSUw7XG4gICAgICAgICAgICAgICAgeHMucHVzaCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdPYmplY3RFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wLnZhbHVlID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gcHJvcC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IHdhbGsocHJvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBGQUlMKSByZXR1cm4gRkFJTDtcbiAgICAgICAgICAgICAgICBvYmpbcHJvcC5rZXkudmFsdWUgfHwgcHJvcC5rZXkubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbicgfHxcbiAgICAgICAgICAgICAgICAgbm9kZS50eXBlID09PSAnTG9naWNhbEV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHdhbGsobm9kZS5sZWZ0KTtcbiAgICAgICAgICAgIGlmIChsID09PSBGQUlMKSByZXR1cm4gRkFJTDtcbiAgICAgICAgICAgIHZhciByID0gd2Fsayhub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChyID09PSBGQUlMKSByZXR1cm4gRkFJTDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG9wID0gbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJz09JykgcmV0dXJuIGwgPT0gcjtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJz09PScpIHJldHVybiBsID09PSByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnIT0nKSByZXR1cm4gbCAhPSByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnIT09JykgcmV0dXJuIGwgIT09IHI7XG4gICAgICAgICAgICBpZiAob3AgPT09ICcrJykgcmV0dXJuIGwgKyByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnLScpIHJldHVybiBsIC0gcjtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJyonKSByZXR1cm4gbCAqIHI7XG4gICAgICAgICAgICBpZiAob3AgPT09ICcvJykgcmV0dXJuIGwgLyByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnJScpIHJldHVybiBsICUgcjtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJzwnKSByZXR1cm4gbCA8IHI7XG4gICAgICAgICAgICBpZiAob3AgPT09ICc8PScpIHJldHVybiBsIDw9IHI7XG4gICAgICAgICAgICBpZiAob3AgPT09ICc+JykgcmV0dXJuIGwgPiByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnPj0nKSByZXR1cm4gbCA+PSByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnfCcpIHJldHVybiBsIHwgcjtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJyYnKSByZXR1cm4gbCAmIHI7XG4gICAgICAgICAgICBpZiAob3AgPT09ICdeJykgcmV0dXJuIGwgXiByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnJiYnKSByZXR1cm4gbCAmJiByO1xuICAgICAgICAgICAgaWYgKG9wID09PSAnfHwnKSByZXR1cm4gbCB8fCByO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gRkFJTDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwodmFycywgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJzW25vZGUubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJldHVybiBGQUlMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwodmFycywgJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJzWyd0aGlzJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJldHVybiBGQUlMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgdmFyIGNhbGxlZSA9IHdhbGsobm9kZS5jYWxsZWUpO1xuICAgICAgICAgICAgaWYgKGNhbGxlZSA9PT0gRkFJTCkgcmV0dXJuIEZBSUw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxlZSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIEZBSUw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjdHggPSBub2RlLmNhbGxlZS5vYmplY3QgPyB3YWxrKG5vZGUuY2FsbGVlLm9iamVjdCkgOiBGQUlMO1xuICAgICAgICAgICAgaWYgKGN0eCA9PT0gRkFJTCkgY3R4ID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB3YWxrKG5vZGUuYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gRkFJTCkgcmV0dXJuIEZBSUw7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxlZS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gd2Fsayhub2RlLm9iamVjdCk7XG4gICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgYWNjZXNzIHRvIG1ldGhvZHMgb24gRnVuY3Rpb24gXG4gICAgICAgICAgICBpZigob2JqID09PSBGQUlMKSB8fCAodHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZBSUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5wcm9wZXJ0eS50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW25vZGUucHJvcGVydHkubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHdhbGsobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gRkFJTCkgcmV0dXJuIEZBSUw7XG4gICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB3YWxrKG5vZGUudGVzdClcbiAgICAgICAgICAgIGlmICh2YWwgPT09IEZBSUwpIHJldHVybiBGQUlMO1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA/IHdhbGsobm9kZS5jb25zZXF1ZW50KSA6IHdhbGsobm9kZS5hbHRlcm5hdGUpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB3YWxrKG5vZGUuZXhwcmVzc2lvbilcbiAgICAgICAgICAgIGlmICh2YWwgPT09IEZBSUwpIHJldHVybiBGQUlMO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdSZXR1cm5TdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Fsayhub2RlLmFyZ3VtZW50KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJvZGllcyA9IG5vZGUuYm9keS5ib2R5O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBcInNjb3BlXCIgZm9yIG91ciBhcmd1bWVudHNcbiAgICAgICAgICAgIHZhciBvbGRWYXJzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICAgICAgICAgIG9sZFZhcnNbZWxlbWVudF0gPSB2YXJzW2VsZW1lbnRdO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8bm9kZS5wYXJhbXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBub2RlLnBhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICBpZihrZXkudHlwZSA9PSAnSWRlbnRpZmllcicpe1xuICAgICAgICAgICAgICAgICAgdmFyc1trZXkubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBGQUlMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBpIGluIGJvZGllcyl7XG4gICAgICAgICAgICAgICAgaWYod2Fsayhib2RpZXNbaV0pID09PSBGQUlMKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZBSUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgdmFycyBhbmQgc2NvcGUgYWZ0ZXIgd2Ugd2Fsa1xuICAgICAgICAgICAgdmFycyA9IG9sZFZhcnM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFycyk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbihrZXlzLmpvaW4oJywgJyksICdyZXR1cm4gJyArIHVucGFyc2Uobm9kZSkpLmFwcGx5KG51bGwsIHZhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ1RlbXBsYXRlTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN0ciArPSB3YWxrKG5vZGUucXVhc2lzW2ldKTtcbiAgICAgICAgICAgICAgICBzdHIgKz0gd2Fsayhub2RlLmV4cHJlc3Npb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciArPSB3YWxrKG5vZGUucXVhc2lzW2ldKTtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHdhbGsobm9kZS50YWcpO1xuICAgICAgICAgICAgdmFyIHF1YXNpID0gbm9kZS5xdWFzaTtcbiAgICAgICAgICAgIHZhciBzdHJpbmdzID0gcXVhc2kucXVhc2lzLm1hcCh3YWxrKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBxdWFzaS5leHByZXNzaW9ucy5tYXAod2Fsayk7XG4gICAgICAgICAgICByZXR1cm4gdGFnLmFwcGx5KG51bGwsIFtzdHJpbmdzXS5jb25jYXQodmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnVGVtcGxhdGVFbGVtZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUuY29va2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgcmV0dXJuIEZBSUw7XG4gICAgfSkoYXN0KTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0ID09PSBGQUlMID8gdW5kZWZpbmVkIDogcmVzdWx0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/static-eval/index.js\n");

/***/ })

};
;